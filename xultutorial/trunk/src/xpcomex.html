

<p>
   Cette section donne quelques exemples d'utilisation de la technologie XPCOM avec de nouvelles interfaces.
   </p>
   <h2>Gestion de Fenêtres</h2>
   <p>
   La liste des fenêtres Mozilla ouvertes peut être utilisée comme une source de données RDF.
   Ceci permet de créer un menu de fenêtre qui donne la liste des fenêtres courantes ouvertes par
   l'application.
   La source de données correspondante est <var>rdf:window-mediator</var> dont voici un exemple
   d'utilisation&nbsp;:</p>

   <p>
   Exemple 7.6.1&nbsp;:
   <a href="exemples/ex_xpcomex_1.xul.txt">Source</a></p>
   <pre><code>&lt;menubar id="windowlist-menubar"&gt;
  &lt;menu label="Fenêtres"&gt;
   &lt;menupopup id="window-menu" datasources="rdf:window-mediator" ref="NC:WindowMediatorRoot"&gt;
    &lt;template&gt;
     &lt;rule&gt;
      &lt;menuitem uri="rdf:*" label="rdf:http://home.netscape.com/NC-rdf#Name"/&gt;
     &lt;/rule&gt;
    &lt;/template&gt;
   &lt;/menupopup&gt;
  &lt;/menu&gt;
 &lt;/menubar&gt;
&lt;/toolbox&gt;</code></pre>
   <p>
   Un menu sera crée contenant la liste de toutes les fenêtres ouvertes.
   Essayez cet exemple en ouvrant plusieurs
   fenêtres , et vous les verrez toutes dans le menu.

   Nous voudrions maintenant améliorer cela de sorte que lorsqu'on sélectionne un élément du menu,
   on aille sur la fenêtre correspondante.
   Ceci sera possible grâce au composant "window mediator" qui implémente
   l'interface <code>nsIWindowDataSource</code>. Le code suivant montre comment il fonctionne&nbsp;:
   </p>
   <pre><code>var wmdata = Components.classes["@mozilla.org/rdf/datasource;1?name=window-mediator"].getService();
      wmdata.QueryInterface(Components.interfaces.nsIWindowDataSource);
      </code></pre>
   <p>
   Ce code récupère le composant "window mediator" qui est un service.
   </p>
   <p>
   L'interface <code>nsIWindowDataSource</code> possède une fonction
   <code>getWindowForResource</code>, qui nous donne une fenêtre
   à partir d'une ressource. Dans un exemple précédent, nous avons généré une liste
   de fenêtres que nous avons ajoutée à un menu via une balise
   <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/template">template</a></code>.
    Celle-ci génère  un attribut <code class="attribut">id</code> pour chaque élément
   <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/menuitem">menuitem</a></code>.
   La valeur de cet attribut peut être utilisée comme ressource.
   Ainsi pour avoir le focus sur la fenêtre sélectionnée, nous pouvons procéder
   de la manière suivante&nbsp;:
   </p>
   <ul>
      <li>Déterminer l'élément que l'utilisateur a sélectionné.</li>
      <li>Récupérer la valeur de l'attribut <code class="attrib">id</code>
          de cet élément.
      </li>
      <li>Passer cette valeur à <code class="attrib">getWindowForResource</code>
         pour avoir l'objet "window".
      </li>
      <li>Mettre le focus sur celle-ci.</li>
   </ul>
   <p>
   L'exemple ci-dessous nous montre comment procéder.
   </p>
   <pre><code>&lt;toolbox&gt;
 &lt;menubar id="windowlist-menubar"&gt;
  &lt;menu label="Fenêtre" oncommand="switchFocus(event.target);"&gt;
   &lt;menupopup id="window-menu" datasources="rdf:window-mediator" ref="NC:WindowMediatorRoot"&gt;
    &lt;template&gt;
     &lt;rule&gt;
      &lt;menuitem uri="rdf:*" label="rdf:http://home.netscape.com/NC-rdf#Name"/&gt;
     &lt;/rule&gt;
    &lt;/template&gt;
   &lt;/menupopup&gt;
  &lt;/menu&gt;
 &lt;/menubar&gt;
&lt;/toolbox&gt;


function switchFocus(elem)
{
  var mediator = Components.classes["@mozilla.org/rdf/datasource;1?name=window-mediator"].getService();
  mediator.QueryInterface(Components.interfaces.nsIWindowDataSource);

  var resource = elem.getAttribute('id');
  switchwindow = mediator.getWindowForResource(resource);

  if (switchwindow){
    switchwindow.focus();
  }
}
      </code></pre>
   <p>
   Un gestionnaire de commande a été ajouté à l'élément menu. Ce gestionnaire appelle
   la fonction <code>switchFocus</code>  avec comme paramètre l'élément du menu que nous avons sélectionné.
   Cette fonction récupère d'abord une
   référence du composant qui implémente l'interface du "window mediator"
   (<acronym title="Note du Traducteur">NdT</acronym>&nbsp;: plus exactement <code>nsIWindowDataSource</code> ).
   Puis nous récupérons l'attribut
   <code class="attribut">id</code> de l'élément. Nous utilisons cette valeur
   comme ressource qui va être passée en paramètre à la fonction <code>getWindowForResource</code>
   pour renvoyer la fenêtre correspondante.
   Cette fenêtre est stockée dans la variable <code>switchwindow</code>
    comme objet javascript window.
   Par conséquent on peut utiliser toutes les fonctions disponibles de cet objet,
   comme la fonction <code>focus()</code>.
   </p>

   <h2>Cookies</h2>
   <p>
   Ensuite, nous allons récupérer la liste des cookies sauvegardés par le
   navigateur. Pour cela on va utiliser le service "Cookie" qui implémente
   l'interface <code>nsICookieManager</code> utilisé pour énumérer tous les cookies.
   Voici un exemple qui alimente la liste d'un menu avec le nom de tous les
   cookies provenant du site MozillaZine.
   </p>

   <pre><code>&lt;script&gt;

function getCookies()
{
  var menu = document.getElementById("cookieMenu");
  menu.removeAllItems();

  var cookieManager = Components.classes["@mozilla.org/cookiemanager;1"]
                        .getService(Components.interfaces.nsICookieManager);

  var iter = cookieManager.enumerator;
  while (iter.hasMoreElements()){
    var cookie = iter.getNext();
    if (cookie instanceof Components.interfaces.nsICookie){
      if (cookie.host == "www.mozillazine.org")
        menu.appendItem(cookie.name,cookie.value);
    }
  }
}
&lt;/script&gt;

&lt;hbox&gt;
  &lt;menulist id="cookieMenu" onpopupshowing="getCookies();"/&gt;
&lt;/hbox&gt;
      </code></pre>

   <p>
   La fonction <code>getCookies</code> sera appelée à chaque ouverture du menu, comme
   indiqué par l'attribut <code class="attribut">onpopupshowing</code> de
   l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/menulist">menulist</a></code>.

   Les deux premières lignes de <code>getCookies</code> récupèrent l'élément <code class="tag">menulist</code> et
   vident tous les items existants. En effet comme cette fonction est appelée
   à chaque fois que nous l'ouvrons, nous ne voulons pas garder les anciens éléments.
   </p>


   <p>
   Puis, le gestionnaire de cookie est récupéré. Celui-ci a une méthode qui
   renvoie un objet énumérateur implémentant <code>nsISimpleEnumerator</code>. Il nous permet de
   parcourir tous les cookies. Un énumérateur a une méthode <code>hasMoreElements</code>
     retournant <var>true</var> jusqu'à ce qu'on récupère le dernier cookie.
     La méthode <code>getNext</code> renvoie un cookie et incrémente l'index de l'énumérateur.

    Comme l'itérateur ne renvoie qu'un objet générique, nous devons lui indiquer
    que nous voulons utiliser l'interface <code>nsICookie</code>.

    Dans ce cas, l'opérateur <code>instanceof</code> permet d'accomplir cette vérification.
   </p>
   <p>
   Finalement, un élément est rajouté au menu pour chaque cookie (
   <acronym title="Note du Traducteur">NdT</acronym>&nbsp;: dont le site
   hôte est "www.mozillazine.org"). Les propriétés hôte, nom et valeur du cookie sont alors utilisées.
   Les menus ont une fonction <code>appendItem</code> qui ajoute un élément avec un libellé et une valeur.
   </p>
   <hr />
   <p>
   Dans la section suivante  nous allons voir comment utiliser le presse papier.
   </p>
