


<p>Nous allons voir maintenant comment utiliser un gabarit avec un arbre.</p>

<h2>Ajouter des sources de données aux arbres</h2>

<p>Quand vous utilisez un arbre, vous utilisez souvent un gabarit pour construire son contenu,
pour manipuler un grand volume de données hiérarchisées. L'utilisation d'un gabarit avec un
arbre est très ressemblante pour la syntaxe aux autres éléments. Vous avez besoin d'ajouter
un attribut <code class="attribut">datasources</code> et <code class="attribut">ref</code> à
la balise <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/tree">tree</a></code>,
ce qui spécifie la source des données et le noeud racine à afficher.
De nombreuses règles peuvent être utilisées pour indiquer différents contenus pour
différents types de données.</p>

<p>L'exemple suivant utilise l'historique comme source de données&nbsp;:</p>

<pre><code>&lt;tree datasources="rdf:history" ref="NC:HistoryByDate" flags="dont-build-content"&gt;
</code></pre>

<p>Comme il est décrit dans la section précédente, l'arbre peut utiliser un <em>constructeur</em> d'arbre
(tree builder) pour la génération du gabarit à la place du constructeur normal de contenu.
Cela signifie que les éléments ne seront pas créés pour chacune des lignes dans l'arbre, le
rendant ainsi plus efficace. Lorsque l'attribut <code class="attribut">flags</code> a pour valeur
<var>dont-build-content</var>, comme dans l'exemple ci-dessus, il indique que le constructeur
de l'arbre doit être utilisé. Si l'attribut n'est pas renseigné, ce sera le constructeur de
contenu qui sera utilisé. Vous pouvez voir la différences en utilisant l'inspecteur DOM de
Mozilla sur un arbre avec, puis sans l'attribut.</p>

<p>Si vous utilisez le constructeur normal à la place, notez que le contenu ne sera pas construit
avant qu'il soit nécessaire. Avec les arbres hiérarchiques, les enfants ne sont pas générés avant
que le noeud parent ne soit ouvert par l'utilisateur.</p>

<p>Dans le gabarit, il n'y aura qu'une cellule <code class="tag">treecell</code> pour chaque
colonne dans l'arbre. Les cellules devront avoir un attribut <code class="attribut">label</code>
afin de mettre un libellé à la cellule. Ceci sera normalement fait dans une propriété RDF pour
que le libellé soit récupéré de la source de données.</p>

<p>L'exemple suivant montre un arbre construit à partir d'un gabarit, dans ce cas le système
de fichier.</p>

<p>Exemple 9.3.1&nbsp;: <a href="exemples/ex_treetempl_1.xul.txt">Source</a>
</p>

<pre><code>
&lt;tree id="my-tree" flex="1"
       datasources="rdf:files" ref="file:///" flags="dont-build-content"&gt;
  &lt;treecols&gt;
    &lt;treecol id="Name" label="Nom" primary="true" flex="1"/&gt;
    &lt;splitter/&gt;
    &lt;treecol id="Date" label="Date" flex="1"/&gt;
  &lt;/treecols&gt;

    &lt;template&gt;
      &lt;rule&gt;
        &lt;treechildren flex="1"&gt;
          &lt;treeitem uri="rdf:*"&gt;
            &lt;treerow&gt;
              &lt;treecell label="rdf:http://home.netscape.com/NC-rdf#Name"/&gt;
              &lt;treecell label="rdf:http://home.netscape.com/WEB-rdf#LastModifiedDate"/&gt;
            &lt;/treerow&gt;
          &lt;/treeitem&gt;
        &lt;/treechildren&gt;
      &lt;/rule&gt;
    &lt;/template&gt;
&lt;/tree&gt;
</code></pre>

<p>Ici, un arbre est créé avec deux colonnes, pour le nom et la date d'un fichier. L'arbre
doit afficher une liste de fichiers situés dans le répertoire racine. Une seule règle est
utilisée, mais vous pouvez en ajouter d'autres si vous en avez besoin. Comme avec les autres
gabarits, l'attribut <code class="attribut">uri</code> d'un élément indique où commencer pour
générer du contenu. Les deux cellules puisent le nom et la date dans la source et place les
valeurs dans le libellé de la cellule.</p>

<p>Cet exemple montre pourquoi l'attribut <code class="attribut">uri</code> devient utile.
Notez comment il a été placé dans le <code class="tag">treeitem</code> dans l'exemple, même si ce
n'est pas un descendant direct de l'élément <code class="tag">rule</code>.
Nous avons besoin de mettre cet attribut seulement sur les éléments que nous voulons répéter pour
chaque ressource. Parce que nous ne voulons pas de multiples éléments <code class="tag">treechildren</code>, nous ne
le mettons pas là. Nous le mettons plutôt dans l'élément <code class="tag">treeitem</code>. En fait, les éléments à
l'extérieur (ou au-dessus) de l'élément qui a l'attribut <code class="attribut">uri</code> ne sont pas dupliqués tandis
que l'élément avec <code class="attribut">uri</code> et les éléments à l'intérieur sont répétés pour chaque ressource.</p>

<p><img src="images/rdfoutl1.jpg" alt="" class="screenshot" />
</p>

<p>Notez dans l'image que des éléments fils additionnels ont été ajoutés automatiquement sous
les éléments du niveau supérieur. XUL sait comment ajouter des éléments fils quand les modèles
ou règles contiennent des éléments arbre ou menu. Il génère alors les éléments d'arbre assemblés
selon les données disponibles dans le RDF.</p>

<p>Une partie intéressante des sources de données RDF est que les valeurs sont déterminées
seulement quand les données sont nécessaires.  Cela signifie que des valeurs qui sont plus
profondes dans la hiérarchie de ressource ne sont pas déterminées jusqu'à ce que l'utilisateur
atteigne ce noeud dans l'arbre.  Ceci devient utile pour certaines sources où les données sont
déterminées dynamiquement.</p>

<h2>Trier les colonnes</h2>

<p>Si vous essayez l'exemple précédent, vous pouvez noter que la liste de dossiers n'est pas triée.
Les arbres qui produisent leurs données à partir d'une source ont la capacité facultative de trier
leurs données.  Vous pouvez trier de façon croissante ou décroissante sur n'importe quelle colonne.
L'utilisateur peut changer la colonne de tri et la direction de tri en cliquant sur les en-têtes de
colonne. Ce dispositif de tri n'est pas disponible pour des arbres dont le contenu est statique,
bien que vous puissiez écrire un script pour trier ces données.</p>

<p>Trier implique trois attributs, qui doivent être placés sur les colonnes.  Le premier attribut,
<code class="attribut">sort</code>, doit être placé sur une propriété de RDF qui est employée alors
comme critère de tri.  Habituellement, c'est la même que celle utilisée dans l'étiquette de la
cellule de cette colonne. Si vous le placez sur une colonne, les données seront triées dans cette
colonne. L'utilisateur peut changer la direction de tri en cliquant sur l'en-tête de colonne.  Si vous
ne placez pas l'attribut <code class="attribut">sort</code> sur une colonne, les données ne peuvent
pas être triées par cette colonne.</p>

<p>L'attribut <code class="attribut">sortDirection</code> (notez la casse mixte) est utilisé pour
définir la direction dans laquelle la colonne sera triée par défaut. Trois valeurs sont possibles&nbsp;:</p>

<ul>
<li><var>ascending</var> : les données sont affichées dans le sens ascendant.</li>
  <li><var>descending</var> :les données sont affichées dans le sens descendant.</li>
  <li><var>natural</var> : les données sont affichées dans le sens "naturel", c'est à
  dire l'ordre dans lequel elles sont stockées dans la source RDF.</li>
</ul>

<p>Le dernier attribut, <code class="attribut">sortActive</code>, doit être défini à <var>true</var>
sur une seule colonne, celle qui sera ordonnée par défaut.</p>

<p>Bien que le tri fonctionnera correctement avec seulement ces attributs, vous pouvez également
utiliser la classe de style <code>sortDirectionIndicator</code> sur une colonne qui peut être triée.
Cela fera apparaître un petit triangle dans l'entête de colonne qui indiquera le sens du tri.
Si vous ne faîtes pas cela, l'utilisateur pourra toujours trier les colonnes mais il n'aura pas
d'indication sur la colonne triée.</p>

<p>L'exemple suivant change les colonnes de l'exemple précédent pour inclure les fonctionnalités
supplémentaires&nbsp;:</p>


<pre><code>&lt;treecols&gt;
  &lt;treecol id="Name" label="Name" flex="1" primary="true"
            class="sortDirectionIndicator" sortActive="true"
            sortDirection="ascending"
            sort="rdf:http://home.netscape.com/NC-rdf#Name"/&gt;
  &lt;splitter/&gt;
  &lt;treecol id="Date" label="Date" flex="1" class="sortDirectionIndicator"
           sort="rdf:http://home.netscape.com/WEB-rdf#LastModifiedDate"/&gt;
&lt;/treecols&gt;</code></pre>


<h2>L'état persistant des colonnes</h2>

<p>Une chose supplémentaire que vous voudriez faire est de rendre persistant la colonne
qui est actuellement triée, ainsi cet état est mémorisé entre chaque session.
Pour ce faire, nous utilisons l'attribut <code class="attribut">persist</code> sur
chaque élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/treecol">treecol</a></code>. Il y a cinq
attribut qu'il serait utile de rendre persistant : la taille de la colonne, l'ordre des
colonne, la visibilité de la colonne, quelle colonne est actuellement triée et dans quel ordre.
L'exemple suivant montre une simple colonne&nbsp;:</p>

<pre><code>&lt;treecol id="Date" label="Date" flex="1"
             class="sortDirectionIndicator"
             persist="width ordinal hidden sortActive sortDirection"
             sort="rdf:http://home.netscape.com/WEB-rdf#LastModifiedDate"/&gt;</code></pre>



<h2>Attributs supplémentaires pour les règles</h2>

<p>Il y a deux attributs que l'on peut ajouter à l'élément
<code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/rule">rule</a></code>, permettant
de l'appliquer dans certaines circonstances. Les deux sont des booléens.</p>

<dl>
  <dt><code class="attribut">iscontainer</code></dt>
  <dd>Si cet attribut est mis à <var>true</var>, alors la règle s'appliquera sur toutes les
      ressources qui peuvent avoir des enfants. Par exemple, nous pouvons appliquer cette règle pour
      récupérer les dossiers des signets. Cela est utile car la source de données n'a
      besoin d'inclure aucun attribut spécial pour indiquer cela.
  </dd>
  <dt><code class="attribut">isempty</code></dt>
  <dd>Si cet attribut est mis à <var>true</var>, alors la règle s'appliquera sur toutes les
      ressources qui n'ont pas d'enfants.
  </dd>
</dl>

<p>Les deux attributs du dessus sont vraiment l'inverse l'un de l'autre. Une ressource pourrait
être un conteneur et être vide en même temps. Toutefois, c'est différent pour une ressource
qui n'est pas un conteneur. Par exemple, un dossier de signets est un conteneur mait il peut avoir
ou ne pas avoir d'enfants. Cependant, un simple signet ou séparateur n'est pas un conteneur.</p>

<p>Vous pouvez combiner ces deux éléments avec d'autres attributs de critères pour des
règles plus spécifiques.</p>
<hr />
<p>Dans la section suivante, nous verrons quelques unes des sources de données fournies par Mozilla.</p>


