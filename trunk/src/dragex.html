


<p>
Un exemple de l'implémentation du glisser-déposer est montré dans cette section.
</p>

<h2>Glisser-déposer des éléments</h2>

<p>
Ici, nous créérons un simple panneau où des items peuvent y être glisser-déposer à partir
d'une palette.
L'utilisateur peut cliquer sur l'un des nombreux éléments XUL de la palette et les glisser
au dessus d'un élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/stack">stack</a></code> pour créer un élément d'un
type particulier.
</p>

<p>
Tout d'abord, nous ajouterons les scripts du conteneur javascript&nbsp;:
</p>


<pre><code>&lt;script src="chrome://global/content/nsDragAndDrop.js"/&gt;
&lt;script src="chrome://global/content/nsTransferable.js"/&gt;

&lt;script src="dragboard.js"/&gt;</code></pre>



<p>
Un script supplémentaire <code>dragboard.js</code> est inclus et contiendra le code
que nous allons écrire nous-même.
</p>

<p>
Le panneau sera créé en utilisant un élément <code class="tag"><a href="http://xulfr.org/wiki/References/Xul/stack">stack</a></code>.
Nous utiliserons quelques propriétés de style pour spécifier la largeur et la hauteur de la pile.
Une taille maximum est aussi spécifiée, ainsi elle ne sera pas redimensionnée lorsque de nouveaux
éléments seront déposés dessus.
</p>

<p>
Le panneau devra répondre à l'évènement <code>dragdrop</code>, en créant un élément
lorsque l'utilisateur en déposera un dessus.
</p>

<pre><code>&lt;stack id="board"
               style="width:300px; height: 300px; max-width: 300px; max-height: 300px"
  ondragover="nsDragAndDrop.dragOver(event,boardObserver)"
  ondragdrop="nsDragAndDrop.drop(event,boardObserver)"&gt;
&lt;/stack&gt;</code></pre>



<p>
Le panneau  a juste besoin de répondre aux évènements <code>dragdrop</code> et <code>dragover</code>.
Nous ajouterons un observateur <code>boardObserver</code> dans le fichier  <code>dragboard.js</code>
dans un moment.
</p>

<p>
Ensuite, une palette sera ajoutée sur le coté droit de la fenêtre. Elle contiendra
trois boutons, un pour créer des nouveaux boutons, un pour créer des cases à cocher,
et un autre pour créer des champs de saisie. Ces boutons répondront à l'évènement
<code>draggesture</code> et débuteront un glisser-déposer.
</p>


<pre><code>&lt;vbox&gt;

&lt;button label="Button"
        elem="button" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;

&lt;button label="Check Box"
        elem="checkbox" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;
&lt;button label="Text Box"
        elem="textbox" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;
&lt;/vbox&gt;</code></pre>



<p>
L'objet <code>nsDragAndDrop</code> sera appelé pour faire la plupart du travail. Nous
créerons un observateur <code>listObserver</code> qui définiera la donnée à transférer.
Notez que chaque bouton ici a un attribut supplémentaire <code class="attribut">elem</code>.
C'est un attribut inventé. XUL ne le reconnait pas et l'ignorera, mais nous pourrons toujours
le récupérer avec la fonction DOM <code>getAttribute</code>. Nous avons besoin de ça pour
savoir quel est le type d'élément à créer lors du glisser-déposer.
</p>

<p>
Ensuite nous définirons deux observateurs. Premièrement, <code>listObserver</code>
qui a besoin d'une fonction pour gérer le démarrage du glisser.
</p>


<pre><code>var listObserver = {
  onDragStart: function (evt,transferData,action){
    var txt=evt.target.getAttribute("elem");
    transferData.data=new TransferData();
    transferData.data.addDataForFlavour("text/unicode",txt);
  }
};</code></pre>


<p>
Une seule fonction a été définie, <code>onDragStart</code>,  et elle sera appelée
par l'objet <code>nsDragAndDrop</code> quand cela sera nécéssaire. La fonction ajoute
la donnée à transférer, à l'objet <code>transferData</code>.
L'attribut <code class="attribut">elem</code> est récupéré à partir de la cible de
l'évènement du glisser-déposer. La cible sera l'élèment sur lequel le glisser-déposer
a commencé. Nous utiliserons la valeur de cet attribut comme donnée pour le glisser.
</p>

<p>
L'objet <code>boardObserver</code> aura besoin de trois fonctions,
<code>getSupportedFlavours</code>, <code>onDragOver</code>, et <code>onDrop</code>.
La fonction <code>onDrop</code> récupèrera la donnée à partir de la session du glisser-déposer
et créera un nouvel élement du type approprié.
</p>


<pre><code>var boardObserver = {
  getSupportedFlavours : function () {
    var flavours = new FlavourSet();
    flavours.appendFlavour("text/unicode");
    return flavours;
  },
  onDragOver: function (evt,flavour,session){},
  onDrop: function (evt,dropdata,session){
    if (dropdata.data!=""){
      var elem=document.createElement(dropdata.data);
      evt.target.appendChild(elem);
      elem.setAttribute("left",""+evt.pageX);
      elem.setAttribute("top",""+evt.pageY);
      elem.setAttribute("label",dropdata.data);
    }
  }
};</code></pre>



<p>
La fonction <code>getSupportedFlavours</code> a seulement besoin de retourner
une liste de type que la pile peut accepter lors de la dépose. Dans notre cas, elle
accepte juste du texte. Nous n'avons pas besoin de faire quelque chose de spécial pour
la fonction <code>onDragOver</code>, ainsi aucun code ne sera ajouté  dans son contenu.
</p>

<p>
Le gestionnaire <code>onDrop</code> utilise tout d'abord la fonction <code>createElement</code> pour créer
un nouvel élément du type stocké dans la session. Ensuite, <code>appendChild</code> est appelée
pour ajouter un nouvel élément à la pile, qui est la cible de l'évènement.
Enfin, nous ajoutons quelques attributs à ce nouvel élément.
</p>

<p>
La position des éléments dans la pile est déterminée par les attributs
<code class="attribut">left</code> et <code class="attribut">top</code>.

Les valeurs des propriétés  <code class="attribut">pageX</code> et
<code class="attribut">pageY</code> contiennent les coordonnées du pointeur de la souris
sur la fenêtre lorsque la dépose a lieu. Cela nous permet de placer le nouvel élément
à la même position que la souris quand le bouton a été relaché.
Ce n'est pas tout a fait le bon moyen de faire cela puisque nous devons en fait
calculer les coordonnées de l'évènement relativement à la pile.
Mais cela fonctionne ici parce que le panneau est dans le coin en haut à gauche de la fenêtre.
</p>

<p>
L'attribut <code class="attribut">label</code>  est défini avec la donnée issue du glisser-déposer,
ainsi le bouton a un libellé par défaut.
</p>

<p>
Cet exemple est assez simple. Un changement possible est d'utiliser un type personnalisé
pour les données plutôt que du texte. Le problème avec l'utilisation du texte est que
si le texte provenant d'un glisser-déposer externe est le mot <var>button</var>, un bouton
sera créé sur le panneau. Un type personnalisé signifie que le panneau
acceptera uniquement les glisser-déposer en provenance de la palette.
</p>

<p>
Le code final est montré en dessous&nbsp;:
</p>


<p>Exemple 7.10.1&nbsp;: <a href="exemples/ex_dragex_1.xul.txt">Source</a></p>

<pre><code>&lt;window title="Composant à déplacer" id="test-window"
  orient="horizontal"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;

&lt;script src="chrome://global/content/nsDragAndDrop.js"/&gt;
&lt;script src="chrome://global/content/nsTransferable.js"/&gt;
&lt;script src="dragboard.js"/&gt;

&lt;stack id="board"
       style="width:300px; height: 300px; max-width: 300px; max-height: 300px"
  ondragover="nsDragAndDrop.dragOver(event,boardObserver)"
  ondragdrop="nsDragAndDrop.drop(event,boardObserver)"&gt;
&lt;/stack&gt;

&lt;vbox&gt;

&lt;button label="Bouton"
        elem="button" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;
&lt;button label="Case à cocher"
        elem="checkbox" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;
&lt;button label="Zone de saisie"
        elem="textbox" ondraggesture="nsDragAndDrop.startDrag(event,listObserver)"/&gt;
&lt;/vbox&gt;

&lt;/window&gt;</code></pre>




<p>Exemple 7.10.2&nbsp;: <a href="exemples/ex_dragex_1.js.txt">Source</a></p>

<pre><code>var listObserver = {
  onDragStart: function (evt,transferData,action){
    var txt=evt.target.getAttribute("elem");
    transferData.data=new TransferData();
    transferData.data.addDataForFlavour("text/unicode",txt);
  }
};

var boardObserver = {
  getSupportedFlavours : function () {
    var flavours = new FlavourSet();
    flavours.appendFlavour("text/unicode");
    return flavours;
  },
  onDragOver: function (evt,flavour,session){},
  onDrop: function (evt,dropdata,session){
    if (dropdata.data!=""){
      var elem=document.createElement(dropdata.data);
      evt.target.appendChild(elem);
      elem.setAttribute("left",""+evt.pageX);
      elem.setAttribute("top",""+evt.pageY);
      elem.setAttribute("label",dropdata.data);
    }
  }
};</code></pre>



<hr />
<p>Dans la section suivante, nous allons voir comment créer des arbres.</p>

