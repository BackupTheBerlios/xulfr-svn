

<p>
    Cette section explique comment manipuler RDF avec un script.
    </p>

    <h2>Sources de données RDF avec <acronym title="Cross-platform Component Object Model">XPCOM</acronym></h2>

    <p>Les gabarits peuvent être utilisés pour extraire les données d'une source RDF et
    construire du contenu à partir de celles-ci. Cependant les sources de
    données peuvent aussi être parcourues à partir d'un script. Vous pouvez obtenir
    la source de données d'un élément construit à partir d'un gabarit et en sélectionner
    des ressources. Cela vous permet aussi de modifier la source de données.</p>

    <p>Le composant XPCOM pour RDF propose un certain nombre d'interfaces. Sont listées ci-aprés
    certaines de ces interfaces&nbsp;:</p>
    <dl>
        <dt>nsIRDFService</dt>
         <dd>Un service global de RDF. Il est utilisé pour générer des objets qui peuvent
         identifier de façon unique une ressource pointant vers une source de données RDF.</dd>
        <dt>nsIRDFDataSource</dt>
         <dd>Represente une source de données RDF, soit intégrée, soit provenant d'un fichier RDF.
         Des méthodes vous permettent d'obtenir ou de placer des valeurs.</dd>
        <dt>nsIRDFContainer</dt>
         <dd>Un noeud conteneur dans une source de données RDF. Des méthodes vous permettent
         d'ajouter et de supprimer des ressources.</dd>
        <dt>nsIRDFContainerUtils</dt>
         <dd>Cette interface a quelques méthodes  pratiques de conteneur pour créer des
         ressources <code class="tag">Seq</code>, <code class="tag">Bag</code>
         et <code class="tag">Alt</code>.</dd>
    </dl>

    <div class="task">
        <p>Dans la fenêtre de recherche de fichiers, nous pouvons implémenter la possibilité de
        stocker les éléments les plus récemment recherchés.
        Le champs de saisie de recherche peut-être remplacé par une liste déroulante éditable qui
        contient une énumération des termes qui ont été récemment recherchés. Nous allons maintenant
        ajouter cette fonctionnalité.</p>

        <p>Cela ne fonctionnera réellement que si la fenêtre a accés à un espace sur le disque
        où la liste des éléments récemments recherchés peut-être enregistrée. Les endroits les plus
        suceptibles de permettre ceci sont le répertoire de profil de l'utilisateur ou un répertoire
        choisi par l'utilisateur lui-même. Bien que nous n'allons pas l'utiliser ici, le répertoire
        du profil de l'utilisateur peut être trouvé en utilisant le composant
        <code>@mozilla.org/file/directory_service;1</code>. Pour simplifier l'exemple, nous allons juste
        mettre un chemin de fichier quelconque dans un attribut
        <code class="attribut">datasources</code>.</p>

        <p>Nous pourrions enregistrer la liste des recherches récentes dans un fichier texte simple.
        Cependant, nous pouvons utiliser RDF qui a déjà la capacité de lire et d'écrire ses données et de
        mettre à jour un composant graphique généré automatiquement à partir d'un gabarit.</p>

        <p>Premièrement, les changements dans le fichier XUL. Nous allons remplacer le champs de saisie
        par une liste
        déroulante éditable. Changez la valeur de l'attribut <code class="attribut">datasources</code>
        par un chemin approprié. (Le fichier doit déjà exister.)
        </p>
        <pre>
            <code>
&lt;menulist id="find-text" flex="1" style="min-width: 15em;"
             editable="true"
             datasources="file:///mozilla/recents.rdf"
             ref="http://www.xulplanet.com/rdf/recent/all"&gt;

  &lt;template&gt;
    &lt;menupopup&gt;
      &lt;menuitem label="rdf:http://www.xulplanet.com/rdf/recent#Label" uri="rdf:*"/&gt;
    &lt;/menupopup&gt;
  &lt;/template&gt;
&lt;/menulist&gt;
            </code>
        </pre>
    </div>
    <p>
    Tous les éléments XUL qui ont leur fils générés par un gabarit ont une propriété <code>database</code>
    qui se référe à un objet <code>nsIRDFDataSource</code>. Cet objet  peut ensuite
    être utilisé pour lire et modifier la source de données utilisée. La propriété <code>
    database</code> est placée sur l'élément qui porte l'attribut <code class="attribut">datasources</code>.
    Cela va typiquement être un élément <code class="tag"><a
    href="http://xulfr.org/wiki/Reference/Xul/tree">tree</a></code>, ou comme c'est le cas ici, un élément
    <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/menulist">menulist</a></code>.
    </p>

    <p>
    La propriété <code>database</code> contient une liste (en fait un
    <code>nsISimpleEnumerator</code>)
    de chacune des sources de données qui ont été spécifiées dans l'attribut <code
    class="attribut">datasources</code>. Cela signifie que nous avons besoin de réitérer chaque élément,
    même s'il n'y en a qu'un seul. L'exemple suivant montre comment réaliser ceci en supposant qu'il
    n'existe qu'une source de données&nbsp;:
    </p>
    <pre><code>var dsource;
var menulist=document.getElementById("find-text");
var sources=menulist.database.GetDataSources();

if (sources.hasMoreElements()){
    dsource=sources.getNext();
}
dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);
        </code>
    </pre>
    <p>
    Tout d'abord, nous obtenons une référence sur un <code class="tag"><a
    href="http://xulfr.org/wiki/Reference/Xul/menulist">menulist</a></code>, qui ici porte l'identifiant
    <var>find-text</var> (attribut <code class="attribut">id</code>). Ensuite nous obtenons la liste des
    sources de données à partir de l'élément <code class="tag"><a
    href="http://xulfr.org/wiki/Reference/Xul/menulist">menulist</a></code>. L'interface
    <code>nsISimpleEnumerator</code>
    a deux méthodes (pareillement à l'interface d'énumération java). Nous bouclons sur les éléments de
    l'énumération et, parce que nous supposons qu'il n'y a en a qu'un, nous allons juste l'obtenir
    par la méthode <code>getNext</code>. Finalement nous appellons <code>QueryInterface</code> pour
    s'assurer qu'il s'agit d'un <code>nsIRDFDataSource</code>.
    </p>

    <div class="task">
        <p>
        Nous allons utiliser un code similaire pour créer la liste des recherches récentes. D'abord,
        initialisons les composants que nous voulons utiliser. Nous aurons besoin de trois composants.
        L'interface <code>nsIRDFService</code> va être utilisée pour créer les objets de ressource, l'interface
        <code>nsIRDFContainer</code> va servir à ajouter des ressources à  la source de données et nous
        utiliserons la troisième interface, <code>nsIRDFContainerUtils</code>, uniquement lorsque la liste
        est employée la première fois, pour créer le noeud racine. Ajoutez le code suivant au début d'un
        fichier de script (findfile.js).
        Il va être exécuté quand la fenêtre de recherche de fichiers est chargée.
        </p>
        <pre><code>const RDFC = '@mozilla.org/rdf/container;1';
RDFC = Components.classes[RDFC].createInstance(Components.interfaces.nsIRDFContainer);

const RDFCUtils = '@mozilla.org/rdf/container-utils;1';
RDFCUtils = Components.classes[RDFCUtils].getService(Components.interfaces.nsIRDFContainerUtils);

const RDF = '@mozilla.org/rdf/rdf-service;1';
RDF = Components.classes[RDF].getService(Components.interfaces.nsIRDFService);
            </code>
        </pre>
        <p>
        Cette portion de code va créer les trois services dont nous avons besoin. La syntaxe est similaire
        à celle utilisée pour les autres créations d'objets XPCOM. Les trois premières lignes prennent une
        référence à un objet <code>nsIRDFContainer</code>. Puis nous exécutons une opération semblable
        pour obtenir l'objet <code>nsIRDFContainerUtils</code>. Enfin nous la faisons de nouveau pour l'objet
        <code>nsIRDFService</code>.
        </p>
        <p>
        Ensuite, nous créons une fonction d'initialisation que nous allons appeler dans l'événement <code
        class="attribut">onload</code> de la fenêtre. Elle va être exécutée quand la fenêtre va être
        affichée. Dans ce source, nous allons ajouter le code pour initialiser les objets RDF que
        nous avons créé plus haut.
        </p>
        <pre>
<em>findfile.xul : </em>
            <code>
&lt;window <strong>onload="initSearchList()"</strong> ... &gt;
            </code>
<em>findfile.js : </em>
            <code>
var dsource;

function initSearchList()
{
    var recentlist=document.getElementById("find-text");
    var sources=recentlist.database.GetDataSources();
    var rootnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all");

    while (sources.hasMoreElements()){
        try {
            dsource=sources.getNext();
            dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);

            RDFC.Init(dsource,rootnode);
        } catch (e) {
            RDFCUtils.MakeSeq(dsource,rootnode);
            RDFC.Init(dsource,rootnode);
        }
    }
}
            </code>
        </pre>
        <p>
        Décomposons la fonction <code>initSearchList</code>&nbsp;:
        </p>
        <dl>
            <dt>
                <pre><code>var recentlist=document.getElementById("find-text");
var sources=recentlist.database.GetDataSources();</code></pre>
            </dt>
             <dd>
             Tout d'abord, nous obtenons une référence sur l'élément <code class="tag"><a
             href="http://xulfr.org/wiki/Reference/Xul/menulist">menulist</a></code> sur lequel est attachée la source de données.
             Elle a une propriété <code>database</code> qui contient les sources de données qui
             sont présentes. Nous obtenons une référence sur les sources de données disponibles et nous
             l'assignons à la variable <code>sources</code>.
             </dd>
            <dt>
                <pre><code>var rootnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all");</code></pre>
            </dt>
             <dd>
             Un objet de ressource est généré avec l'<acronym title="Uniform Ressource Identifier">URI</acronym>
             donnée. Il sera l'élément racine, un élément RDF <code class="tag">Seq</code> qui
             contient une liste de ressources, une pour chaque objet présent dans la liste des recherches
             récentes. Cette fonction ne retire rien de la source de données, elle convertit juste une URI en
             un identifiant de ressource. Au lieu d'inscrire l'URI dans le code, nous pourrions aussi
             l'obtenir à  partir de l'attribut <code class="attribut">ref</code>.
             </dd>
            <dt>
                <pre><code>while (sources.hasMoreElements()){
    try {
        dsource=sources.getNext();
        dsource=dsource.QueryInterface(Components.interfaces.nsIRDFDataSource);</code></pre>
            </dt>
             <dd>
             Aprés, nous bouclons sur chaque source de données afin d'obtenir la bonne.
             </dd>
             <dt>
                 <pre><code> RDFC.Init(dsource,rootnode);</code></pre>
             </dt>
              <dd>
              Cette fonction initialise le conteneur RDF (l'interface nsIRDFContainer) avec la source de
              données et le noeud racine. Plus tard, nous pouvons utiliser l'objet pour ajouter de nouvelles
              ressources à l'interieur du conteneur. Nous aurons besoin de faire cela pour ajouter un article
              recherché à la source de données.
              Une erreur se produira si la source de données ou le noeud racine n'existe pas (par exemple,
              si le fichier RDF n'a pas été trouvé). Le code a été mis dans un block "try-catch" pour
              assurer la gestion des erreurs.
              </dd>
             <dt>
                 <pre><code>} catch (e){
    RDFCUtils.MakeSeq(dsource,rootnode);
    RDFC.Init(dsource,rootnode);
}</code></pre>
             </dt>
              <dd>
              Si une erreur se produit, c'est trés probablement parce que le noeud racine n'existe pas.
              Pour le créer, nous appellons la méthode <code>MakeSeq</code> de l'interface
              <code>nsIRDFContainerUtils</code>. Des
              fonctions similaires existent pour créer des éléments <code class="tag">Bag</code> et
              <code class="tag">Alt</code>. (<code>MakeBag</code> et <code>MakeAlt</code>). On essaie ensuite
              de réinitialiser le conteneur.
              </dd>
        </dl>
        <p>
        L'interface <code>nsIRDFService</code> contient une méthode <code>GetResource</code> qui crée pour
        nous un objet de ressource à  partir de la chaîne de caractères passée en argument.
        Cette méthode ne récupére aucune valeur, mais convertit simplement une chaîne de caractères en un
        objet ressource que l'on peut utiliser pour obtenir la valeur à partir  de la source de données.
        Les interfaces RDF n'employent pas de chaînes de caractères mais utilisent plutôt des ressources
        pour se référer au contenu.
        La valeur retournée par <code>GetResource</code> est de type <code>nsIRDFResource</code>.
        </p>
        <p>
        Maintenant que les objets ont été initialisés, nous pouvons ajouter et enlever des informations à
        la source de données. Il y a deux méthodes requises selon si vous voulez ajoutez une ressource à
        un conteneur ou si vous voulez ajouter une liaison d'une ressource vers une autre. Ces deux
        cas correspondent à l'ajout d'un marque-page et à l'ajout d'une propriété comme un <acronym
        title="Uniform Resource Locator">URL</acronym> ou un titre à un marque-page.
        </p>
        <p>
        Nous allons ajouter une nouvelle entrée à la liste des éléments recherchés quand l'utilisateur
        cliquera sur le bouton de recherche. Nous le simplifierons un peu à l'extrême de plusieurs manières.
        Tout d'abord nous ne prendrons pas la peine de vérifier les entrées doubles. Deuxièmement,
        nous ne nous soucierons pas de limiter la longueur de la liste.
        </p>
        <p>
        Ajoutons une autre fonction qui est appelée à  partir de la fonction <code>doFind</code>&nbsp;:
        </p>
        <pre>
            <code>
function doFind()
{
    <strong>var recentlist=document.getElementById("find-text");
    var fldval=recentlist.value;

    addSearchedItem(fldval);
    </strong>
.
.
.
            </code>
        </pre>
        <p>
        Cette portion de code prend la valeur saisie dans la liste déroulante éditable et nous passons
        le texte à la fonction <code>addSearchedItem</code> qui va être définie plus loin.
        </p>
        <pre>
            <code>
function addSearchedItem(txt)
{
    var newnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all/item"+(RDFC.GetCount()+1));
    var labelprop=RDF.GetResource("http://www.xulplanet.com/rdf/recent#Label");
    var newvalue=RDF.GetLiteral(txt);

    dsource.Assert(newnode,labelprop,newvalue,true);
    RDFC.InsertElementAt(newnode,1,true);

    dsource.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource).Flush();
}
            </code>
        </pre>
        <p>
        Ce code fait trois choses, il ajoute une nouvelle ressource, il ajoute un nouvel enregistrement
        qui contient la valeur, et ensuite il enregistre la source de données modifiée.
        Décomposons le code&nbsp;:
        </p>
        <dl>
            <dt>
                <pre><code>var newnode=RDF.GetResource("http://www.xulplanet.com/rdf/recent/all/item"+(RDFC.GetCount()+1));</code></pre>
            </dt>
             <dd>
             Cette ligne crée un objet ressource pour la ressource qui va être ajoutée. La fonction
             <code>GetCount</code> retourne le nombre de ressources déjà présentes dans le conteneur.
             Cela nous permet de générer une URI unique. Nous pouvons aussi appeler
             <code>GetAnonymousResource</code> (à  la place de <code>GetResource</code>) qui ne prend
             pas de paramètre et génère au hasard une URI unique.
             </dd>
            <dt>
                <pre><code>var labelprop=RDF.GetResource("http://www.xulplanet.com/rdf/recent#Label");</code></pre>
            </dt>
             <dd>
             Nous placerons dans la propriété <code>Label</code> de la ressource le texte qui a été
             récemment cherché.
             Vous pouvez utiliser n'importe quel nom de propriété pourvu qu'il soit conforme. Vous noterez
             qu'il a la même valeur que l'attribut <code class="attribut">label</code> de l'élément
             <code class="tag">menuitem</code> ajouté précédemment au fichier XUL.
             </dd>
            <dt>
                <pre><code>var newvalue=RDF.GetLiteral(txt);</code></pre>
            </dt>
             <dd>
             La fonction <code>GetLiteral</code> génére un objet RDF de type chaîne qui va contenir le texte que
             l'utilisateur a recherché et passé à  travers l'argument <code>txt</code>.
             Nous n'utilisons pas la fonction <code>GetResource</code> ici car nous assignons une valeur à
             une ressource.
            </dd>
            <dt>
                <pre><code>dsource.Assert(newnode,labelprop,newvalue,true);</code></pre>
            </dt>
             <dd>
             Cette ligne va ajouter une liaison à la source de données RDF. Dans ce cas, elle dit
             que la propriété <var>Label</var> de la ressource <var>http://www.xulplanet.com/rdf/recent/all/itemX</var>
             est l'objet littéral qui a été créé à la ligne précédente, où X est le nombre retourné par
             la fonction <code>GetCount</code>.
             Cependant, ce n'est que la moitié de ce qu'il faut faire. Nous devons encore
             dire que la ressource est une des recherches récentes.
             </dd>
            <dt>
                <pre><code>RDFC.InsertElementAt(newnode,1,true);</code></pre>
            </dt>
             <dd>
             Cette ligne ajoute la ressource au conteneur. Ici, nous l'insérons en position 1.
             (Notons que le premier élément est 1 et non 0.) Nous pouvons l'insérer partout, ou
             appeler <code>AppendElement</code> à  la place pour l'ajouter à  la fin. Le gabarit menulist va
             maintenant détecter la nouvelle ressource, et ajoutera une rangée suplémentaire dans la
             liste.
             </dd>
            <dt>
                <pre><code>dsource.QueryInterface(Components.interfaces.nsIRDFRemoteDataSource).Flush();</code></pre>
            </dt>
             <dd>
             Enfin, nous écrivons la source de données sur le disque en utilisant la fonction <code>Flush</code>.
             Cette fonction ne fait pas partie de l'interface <code>nsIRDFDataSource</code>, donc nous
             devons d'abord appeller <code>QueryInterface</code> pour convertir la source de données vers la bonne
             interface, <code>nsIRDFRemoteDataSource</code>.
             </dd>
        </dl>
        <p class="note">
        Toutes les sources de données ne peuvent pas être modifiées. Toutes les sources de données
        chargées à partir de fichiers et d'URLs de ressource peuvent être écrites
        aussi bien que des sources de données internes.
        </p>
        <p>
        Si vous ouvrez la fenêtre de recherche de fichiers, que vous entrez du texte puis pressez
        "Recherche", vous constaterez que le texte apparait en tant qu'un des choix dans
        la liste déroulante. Même si vous quittez puis redémarrez, le texte restera dans la liste
        déroulante.
        </p>
    </div>
    <p>
    Pour vérifier les entrées dupliquées, nous pouvons vérifier les ressources existantes, en utilisant
    les fonctions <code>hasAssertion</code> ou <code>GetAllRessources</code> de l'interface <code>nsIRDFDataSource</code>.
    </p>
    <p>
        Exemple de recherche de fichier&nbsp;:
        <a href="exemples/findfile/findfile-rdfscript.xul.txt">Source</a>
        <a href="exemples/findfile/findfile-rdfscript.xul" onclick="window.open('exemples/findfile/findfile-rdfscript.xul','xulff','chrome,resizable'); return false;">Voir</a>
    </p>
    <hr />
    <p>
        Nous allons voir maintenant comment accéder au presse-papier du système pour les opérations copier
        et coller.
    </p>

