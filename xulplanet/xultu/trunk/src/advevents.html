
<p>Dans cette section, l'objet évènement sera examiné et des évènements additionnels seront décrits.</p>

<h2>L'objet évènement</h2>

<p>Chaque gestionnaire d'évènement dispose d'un unique argument qui contient un objet évènement. Pour le fonctionnement des scrutateurs d'évènements, cet évènement est un argument implicite auquel un script peut se référer en utilisant le nom <var>event</var>. Sous la forme <code>addEventListener</code>, le premier argument de la fonction scrutatrice sera un objet évènement. L'objet <var>event</var> dispose d'un certain nombre de propriétés qui peuvent être examinées lors d'un évènement. La liste complète est disponible dans <a href="http://xulplanet.com/references/objref/Event.html">les références objets</a>.</p>

<p>Nous avons déjà vu la propriété <var>target</var> d'un évènement dans la section précédente. Elle contient une référence de l'élément ayant déclenché l'évènement. Une propriété similaire <var>currentTarget</var> contient l'élément sur lequel est placé un scrutateur d'évènement. Dans l'exemple ci-dessous, <var>currentTarget</var> pointe toujours la boîte <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code>, alors que la cible peut être un élément spécifique, soit le bouton ou soit la case à cocher, qui a été activé.</p>

<p>Exemple 6.2.1&nbsp;:
<a href="exemples/ex_advevents_1.xul.txt">Source</a>
<a href="exemples/ex_advevents_1.xul" onclick="window.open(this.href,'xulex','chrome,resizable'); return false;"
>Voir</a></p>

<pre><code>&lt;vbox oncommand="alert(event.currentTarget.tagName);"&gt;
  &lt;button label="OK"/&gt;
  &lt;checkbox label="Voir les images"/&gt;
&lt;/vbox&gt;</code></pre>

<p>Rappelez vous que la phase de capture intervient avant la phase de diffusion, donc tous les scrutateurs de capture sont déclenchés avant les scrutateurs de diffusion. Si un évènement capturé stoppe la propagation événementielle, aucun des scrutateurs de capture suivants, ou de ceux de diffusion ne recevront jamais de notification d'un quelconque évènement. Pour interrompre la propagation événementielle, appelez la méthode <code>stopPropagation</code> de l'objet évènement, comme dans l'exemple suivant.</p>

<p>Exemple 6.2.2&nbsp;:
<a href="exemples/ex_advevents_2.xul.txt">Source</a>
<a href="exemples/ex_advevents_2.xul" onclick="window.open(this.href,'xulex','chrome,resizable'); return false;"
>Voir</a></p>

<pre><code>&lt;hbox id="outerbox"&gt;
  &lt;button id="okbutton" label="OK"/&gt;
&lt;/hbox&gt;

&lt;script&gt;
function buttonPressed(event)
{
  alert('Le bouton a été pressé !');
}

function boxPressed(event)
{
  alert('La boîte a été pressée !');
  event.stopPropagation();
}

var button = document.getElementById("okbutton");
button.addEventListener('command',buttonPressed,true);

var outerbox = document.getElementById("outerbox");
outerbox.addEventListener('command',boxPressed,true);
&lt;/script&gt;</code></pre>

<p>Ici, un scrutateur d'évènement a été ajouté au bouton, et un autre à la boîte. La méthode <code>stopPropagation</code> est appelée dans le scrutateur de la boîte, donc le scrutateur du bouton ne sera jamais appelé. Si cet appel est enlevé, les deux scrutateurs seront appelés et les deux alertes apparaîtront.</p>

<p>Si aucun gestionnaire d'évènement n'a été enregistré pour un évènement, alors après avoir accompli les phases de capture et de diffusion, l'élément traitera l'évènement dans un mode par défaut. L'action dépendra de la nature de l'évènement et du type d'élément. Par exemple, l'évènement <var>popupshowing</var> est envoyé par un menu surgissant juste avant son affichage. L'action par défaut est l'affichage du menu surgissant. Si l'action par défaut est bloquée, l'affichage ne se fera pas. L'action par défaut peut être empêchée avec la méthode <code>preventDefault</code> de l'objet évènement, comme dans l'exemple ci-dessous.</p>

<p>Exemple 6.2.3&nbsp;:
<a href="exemples/ex_advevents_3.xul.txt">Source</a>
<a href="exemples/ex_advevents_3.xul" onclick="window.open(this.href,'xulex','chrome,resizable'); return false;"
>Voir</a></p>

<pre><code>&lt;button label="Types" type="menu"&gt;
  &lt;menupopup onpopupshowing="event.preventDefault();"&gt;
    &lt;menuitem label="Verre"/&gt;
    &lt;menuitem label="Plastique"/&gt;
  &lt;/menupopup&gt;
&lt;/button&gt;</code></pre>

<p>Alternativement, pour des scrutateurs d'évènement attribués, vous pouvez simplement faire renvoyer la valeur <var>false</var> par le code. Notez que l'empêchement de l'action par défaut n'est pas la même chose que d'interrompre la propagation événementielle avec la méthode <code>stopPropagation</code>. Même si l'action par défaut a été bloquée, l'évènement continue à se propager. De même, l'appel de la méthode <code>stopPropagation</code> ne bloquera pas l'action par défaut. Vous devrez appeler ces deux méthodes pour interrompre les deux actions.</p>

<p class="note">Notez qu'une fois la propagation ou l'action par défaut bloquée, il n'est pas possible de les rendre actives de nouveau pour cet évènement.</p>

<p>Les sous-sections ci-dessous listent quelques uns des évènements pouvant être utilisés. Une liste complète est fournie dans <a href="http://www.xulplanet.com/references/elemref/ref_EventHandlers.html">la référence des évènements</a>.</p>


<h2>Évènements de la souris</h2>

<p>Il y a plusieurs évènements pouvant être employés pour gérer les actions de la souris, listés dans le tableau suivant&nbsp;:</p>

<dl>
  <dt><var>click</var></dt>
    <dd>appelé lorsque la souris est appuyée et relâchée sur un élément.</dd>
  <dt><var>dblclick</var></dt>
    <dd>appelé lorsque la souris est double-cliquée.</dd>
  <dt><var>mousedown</var></dt>
    <dd>appelé lorsqu'un bouton de la souris est appuyé. Le gestionnaire d'évènement est appelé aussitôt que le bouton de la souris est appuyé, même s'il n'a pas été relâché.</dd>
  <dt><var>mouseup</var></dt>
    <dd>appelé lorsque la souris est relâchée sur un élément.</dd>
  <dt><var>mouseover</var></dt>
    <dd>appelé lorsque le pointeur de la souris survole un élément. Vous pourriez utiliser cet évènement pour mettre en valeur l'élément, toutefois CSS fournit une façon automatique de le faire, il est donc inutile de le faire avec un évènement. Vous pouvez toutefois l'utiliser pour afficher une aide dans la barre d'état.</dd>
  <dt><var>mousemove</var></dt>
    <dd>appelé lorsque le pointeur de la souris bouge au dessus d'un élément. L'évènement étant appelé à chaque mouvement de la souris par l'utilisateur, vous devriez éviter les tâches trop longues avec ce gestionnaire.</dd>
  <dt><var>mouseout</var></dt>
    <dd>appelé lorsque le pointeur de la souris quitte un élément. Vous pourriez annuler la mise en valeur de l'élément ou effacer le texte de la barre d'état.</dd>
</dl>

<p>Il existe également un jeu d'évènements relatifs au déplacement, qui intervient lorsque l'utilisateur maintient le bouton de la souris enfoncé et déplace la souris. Ces évènements seront décrits dans <a href="dragdrop.html">la section Glisser-Déposer</a>.</p>

<p>Lorsqu'un évènement sur un bouton de la souris se produit, un nombre de propriétés additionnelles est disponible pour déterminer quels boutons ont été pressés et la position du pointeur de la souris. La propriété de l'évènement sur le bouton peut être utilisée pour déterminer quel bouton a été pressé, avec les valeurs possibles de <var>0</var> pour le bouton de gauche, <var>1</var> pour le bouton de droite, et <var>2</var> pour le bouton du milieu. Si vous avez configuré votre souris différemment, ces valeurs peuvent être différentes.</p>

<p>La propriété détaillée contient le nombre de fois que le bouton a été cliqué rapidement en séquence. Elle permet de tester des clics simples, doubles ou triples. Bien entendu, si vous ne souhaitez tester que les double-clics, vous pouvez également utiliser l'évènement <var>dblclick</var> à la place. L'évènement <var>click</var> sera lancé dès le premier clic, puis de nouveau pour le second clic, puis pour le troisième clic, mais l'évènement <var>dblclick</var> ne sera lancé que pour un double-clic.</p>

<p>Le bouton et les propriétés détaillées ne s'appliquent qu'aux évènements se rapportant aux boutons de la souris, et non aux mouvements de la souris. Pour l'évènement <var>mousemove</var>, par exemple, l'ensemble de ces propriétés aura une valeur de <var>0</var>.</p>

<p>Toutefois, tous les évènements de la souris disposent des propriétés contenant les coordonnées de la position de la souris lors du déclenchement de l'évènement. Il y a deux jeux de coordonnées. Le premier jeu est les propriétés <code>screenX</code> et <code>screenY</code> mesurées relativement par rapport au coin supérieur gauche de l'écran. Le second jeu, <code>clientX</code> et <code>clientY</code>, est calculé à partir du coin supérieur gauche du document. Voici un exemple qui affiche les coordonnées actuelle de la souris&nbsp;:</p>

<p>Exemple 6.2.4&nbsp;:
<a href="exemples/ex_advevents_4.xul.txt">Source</a>
<a href="exemples/ex_advevents_4.xul" onclick="window.open(this.href,'xulex','chrome,resizable'); return false;"
>Voir</a></p>

<pre><code>&lt;script&gt;

function updateMouseCoordinates(event)
{
  var text = "X:" + event.clientX + " Y:" + event.clientY;
  document.getElementById("xy").value = text;
}
&lt;/script&gt;

&lt;label id="xy"/&gt;
&lt;hbox width="400" height="400" onmousemove="updateMouseCoordinates(event);"/&gt;</code></pre>

<p>Dans cet exemple, la taille de la boîte a été explicitement fixée pour que l'effet soit plus facile à voir. Le gestionnaire d'évènement récupère les propriétés <code>clientX</code> et <code>clientY</code> et crée une chaîne avec eux. Cette chaîne est affectée à la propriété <code class="attribut">value</code> d'un libellé.</p>
<p class="note">Notez que l'argument <var>event</var> doit être passé à la fonction updateMouseCoordinate. Si vous déplacez rapidement la souris autour de la bordure, vous noterez que les coordonnées ne s'arrêtent généralement pas exactement sur <var>400</var>. Ceci s'explique car l'évènement <var>mousemove</var> se déclenche selon un intervalle dépendant de la vitesse de déplacement de la souris, et celle-ci s'est généralement déplacée au delà de la bordure avant le lancement de l'évènement suivant. Évidement, il ne serait pas efficace d'envoyer un évènement <var>mousemove</var> sur chacun des pixels parcourus par la souris.</p>

<p>Souvent, vous ne voulez obtenir les coordonnées relatives qu'à l'élément qui a déclenché l'évènement plutôt qu'à la fenêtre entière. Il vous suffit de soustraire la position de l'élément à la position de l'évènement, comme pour le code suivant.</p>

<pre><code>var element = event.target;
var elementX = event.clientX - element.boxObject.x;
var elementY = event.clientY - element.boxObject.y;</code></pre>

<p>Les éléments XUL ont un objet de boîte qui peut être accédé en utilisant la propriété <code>boxObject</code>. Nous en apprendrons plus sur l'objet de boîte dans une section ultérieure, mais sachez qu'il contient des informations sur comment est affiché l'élément, en incluant la position x et y de l'élément. Dans cet exemple de code, ces coordonnées sont soustraites de celles de l'évènement pour obtenir la position relative de l'élément.</p>

<h2>Évènements de chargement</h2>

<p>L'évènement de chargement est envoyé au document (l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/window">window</a></code>) dès que le fichier XUL a fini son chargement et juste avant que son contenu ne soit affiché. Cet évènement est couramment utilisé pour initialiser les champs et réaliser d'autres tâches qui doivent être faites avant que l'utilisateur ne dispose de la fenêtre. Vous devriez utiliser un évènement de chargement pour faire ce genre de chose par opposition à l'ajout d'un script de niveau supérieur extérieur à une fonction. Cette préconisation vaut car les éléments XUL peuvent ne pas être chargés et être totalement initialisés, en engendrant des dysfonctionnements. Pour utiliser un évènement de chargement, placez l'attribut <code class="attribut">onload</code> sur l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/window">window</a></code>. Appelez du code à l'intérieur du gestionnaire de chargement afin d'initialiser l'interface si nécessaire.</p>

<p>Il existe également un évènement <code class="attribut">unload</code> qui est appelé dès que la fenêtre est fermée, ou dans un contexte de navigation, lorsque la page bascule vers une autre URL. Vous pouvez utiliser cet évènement pour sauvegarder des informations modifiées, par exemple.</p>

<hr />

<p>Nous verrons ensuite comment ajouter des raccourcis clavier.</p>

