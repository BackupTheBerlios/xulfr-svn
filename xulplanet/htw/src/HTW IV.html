
<p>Une fois que le constructeur de gabarits a compilé les règles, l'analyse des règles et la génération du contenu peut commencer. Le constructeur de gabarits génère le contenu de manière paresseuse, c'est-à-dire qu'il ne réalise un traitement que lorsque c'est nécessaire, et qu'il ne continue que si c'est nécessaire. Considérons par exemple le cas suivant&nbsp;:</p>

<pre><code>&lt;vbox datasources="http://www.xulplanet.com/ds/sample.rdf"
         ref="http://www.xulplanet.com/rdf/A" hidden="true"&gt;
  &lt;template&gt;
    ...
  &lt;/template&gt;
&lt;/vbox&gt;</code></pre>

<p>La <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> est masquée comme indiqué par l'attribut <code class="attribut">hidden</code>. Comme tout le contenu pouvant être généré ne pourrait pas être affiché, le constructeur de gabarits ne fait rien, en repoussant le travail à plus tard. Si maintenant, vous affichez la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> en mettant l'état <var>false</var> sur l'attribut <code class="attribut">hidden</code>, le constructeur de gabarits sera appelé et le contenu généré.</p>

<p>Est-ce que cela signifie que les gabarits ne peuvent pas être utilisés dans des endroits cachés de l'interface utilisateur&nbsp;? Non, vous pouvez toujours encore le faire. La modification de l'état <code class="attribut">hidden</code> d'un élément n'est pas le seul moyen pour provoquer la génération du contenu. L'appel d'une API DOM qui nécessite de récupérer le contenu généré, va relancer le constructeur de gabarits. Par exemple, l'appel du code suivant sur la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> masquée ci-dessus va mettre en route le constructeur de gabarits&nbsp;:</p>

<pre><code>var length = vbox.childNodes.length;</code></pre>

<p>Cette requête demandant le nombre d'enfants de la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> va obliger le  constructeur de gabarits à traiter les règles et à générer le contenu. Ensuite, le nombre correct peut être retourné.</p>

<p>Tout cela est transparent pour le développeur XUL. Le moment où le constructeur de gabarits commence la génération est déterminé automatiquement sans rien faire de spécial. Cependant, il y a deux cas ou le contenu n'est pas généré automatiquement&nbsp;: les menus et les items d'un arbre.</p>

<p>Le contenu à l'intérieur d'un menu n'est généré que quand le menu est ouvert. Ce fonctionnement est logique puisque l'utilisateur ne peut voir le contenu tant qu'il ne l'a pas ouvert. Toutefois, cela signifie aussi que l'utilisation de l'API DOM, telle que d'essayer de connaître le nombre de noeuds enfants comme ci-dessus, n'inclura pas les items générés avant que le menu ne soit ouvert. Il s'agit d'une distinction importante. Elle signifie que vous ne pouvez pas espérer obtenir les items du menu généré avant que celui-ci ne soit ouvert. Un principe semblable s'applique aux items enfants d'un arbre. Les branches filles ne sont générées qu'une fois que l'utilisateur appuie sur le symbole d'exploration (<abbr title="Note du traducteur">NdT</abbr>&nbsp;: twisty) pour ouvrir le conteneur, ou qu'un script n'ouvre une ligne.</p>

<p>La génération paresseuse est pratique pour les menus et les arbres notamment lors de traitements récursifs. Il serait trop long de générer une sortie pour chaque item d'un arbre, même ceux qui ne sont pas affichés, donc le constructeur de gabarits évite donc de le faire.</p>

<p>Le constructeur de gabarits est même plus paresseux que cela. Si le contenu généré contient des éléments masqués, ces éléments enfants ne seront pas générés tant ce que n'est pas nécessaire. Quand il construit le contenu, le constructeur parcourt les noeuds de l'arbre, en ne copiant et en ne construisant que ce qui est nécessaire.</p>

<p>Par la suite nous allons voir comment le constructeur de gabarits analyse les règles.</p>
