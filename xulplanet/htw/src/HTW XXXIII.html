
<p>Tout élément inséré dans un document XUL est vérifié pour voir s'il contient un attribut <code class="attribut">datasources</code>. Si c'est le cas, un constructeur de gabarits sera créé pour cet élément et lui sera attaché. Si l'élément est un <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/tree">tree</a></code> avec un attribut <var>dont-build-content</var>, un constructeur d'arbre sera créé. Autrement, c'est un constructeur de contenu qui sera créé. Ces deux types de constructeur partage sensiblement le même code sauf la méthode leur servant à l'affichage. Ils implémentent tous les deux <a href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIXULTemplateBuilder.html">l'interface nsIXULTemplateBuilder</a>, mais le constructeur d'arbre implémente également <a href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIXULTreeBuilder.html">l'interface nsIXULTreeBuilder</a>.

<p>Le constructeur associé à un élément est accessible via la propriété <code>builder</code> de l'élément aussi bien pour les constructeurs de contenu que pour les constructeurs d'arbre. Un élément qui n'est pas associé à un constructeur a cette propriété définit à <var>null</var>. Le processus de création de cette propriété <code>builder</code> pour un élément s'applique après que la fenêtre soit chargée lorsque un élément est créé, et lorsqu'un élément est inséré dynamiquement.</p>

<p>Les gabarits ne peuvent être utilisés que dans des documents XUL, toutefois rien n'oblige à ce qu'ils génèrent des éléments XUL. Ils pourraient également servir, par exemple, à générer des éléments HTML. Il ne s'agit cependant pas d'une pratique courante. Voici un exemple de cet usage&nbsp;:</p>

<pre><code>&lt;html:div id="photosList" datasources="template-guide-photos5.rdf"
          ref="http://www.xulplanet.com/rdf/myphotos"
          xmlns:html="http://www.w3.org/1999/xhtml"&gt;
  &lt;html:h1&gt;Mes Photos&lt;/html:h1&gt;
  &lt;template&gt;

    &lt;html:p uri="rdf:*"&gt;&lt;textnode value="rdf:http://purl.org/dc/elements/1.1/title"/&gt;&lt;/html:p&gt;
  &lt;/template&gt;
&lt;/html:div&gt;</code></pre>

<p><a href="exemples/template-guide-ex33.xul" onclick="window.open(this.href,'xulex','chrome,resizable'); return false;">Cet exemple</a> génère trois paragraphes. Du contenu statique placé avant l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/template">template</a></code> affiche un en-tête &lt;h1&gt;. Puisque les gabarits ont été conçus pour la création de contenu XUL, des résultats inattendus peuvent se produire avec l'utilisation du HTML. Parfois, cela est dû à la gestion différente des espaces vides entre HTML et XUL, et qui explique pourquoi dans l'exemple ci-avant, le contenu généré se trouve sur une seule ligne. Si vous prévoyez de générer du contenu non-XUL avec un gabarit, pensez à ce problème.</p>

<p class="note">Notez que les versions plus récentes de Mozilla ont corrigé ce problème particulier d'espaces vides.</p>

<p>Vous noterez que l'attribut <code class="attribut">datasources</code> a été placé sur un élément non-XUL. Cela est également permis. Cependant, sachez que les éléments non-XUL n'auront pas leur contenu généré paresseusement et que par conséquence, tout le contenu sera généré immédiatement. Soyez prudent que la récursivité de vos gabarits ne soit pas trop profonde.</p>

<p>La propriété <code>builder</code> est une propriété de <a href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIDOMXULElement.html">l'interface nsIDOMXULElement</a>, donc tous les éléments XUL en disposeront, bien que comme mentionné juste avant, elle sera défini à <var>null</var> pour la plupart des éléments. Pour des éléments non-XUL, le constructeur de gabarits assignera une propriété <code>builder</code> à l'élément en utilisant une propriété JavaScript standard à la place.</p>

<p>La raison principale d'accéder à la propriété <code>builder</code> d'un élément est de pouvoir appeler sa méthode "<code>rebuild</code>". Cette méthode supprime tout le contenu généré existant et efface toutes les données dans le réseau d'information des règles. Ensuite, la méthode recompile les règles et régénère le contenu. Plus précisément, la méthode <code>rebuild</code> informe le constructeur de supprimer toutes les informations existantes et de les reconstruire depuis le début. La seule différence est que les données sont les mêmes puisque la source de données est déjà chargée. Toutefois, cette méthode est souvent utilisée quand vous modifiez la source de données ou les règles.</p>

<p>La méthode <code>refresh</code> de la propriété <code>builder</code> va cependant recharger les sources de données. Il ne s'agit pas d'une reconstruction des gabarits, mais nous verrons dans une section ultérieure pourquoi ce n'est pas nécessaire. Pour résumer, la méthode <code>refresh</code> recharge les données tandis que la méthode <code>rebuild</code> reconstruit le contenu.</p>

<p>La propriété <code>builder</code> est accessible aux codes sans privilèges, donc les méthodes <code>rebuild</code> et <code>refresh</code> peuvent être appelées par du code distant.</p>

<p>Nous allons ensuite voir quelques exemples de reconstruction de gabarits.</p>
