
<p>Le second type de scrutateur est utilisé pour traiter des actions particulières relatives aux arbres. Le constructeur d'arbres implémente l'interface <a href="http://www.xulplanet.com/references/xpcomref/ifaces/nsITreeView.html">nsITreeView</a>, donc il gère l'assemblage et la transmission des données vers l'arbre. Les composants graphiques de l'arbre informe la vue d'arbre lorsque certaines opérations pouvant affecter les données sont réalisées. La vue d'arbre gère toutes ces opérations, mais elle permet que soit attaché un observateur qui est invoqué pendant ces opérations. Par exemple, l'observateur peut avoir une méthode <code>onToggleOpenState</code> qui sera appelée quand l'utilisateur ouvre ou ferme une ligne. Le constructeur d'arbres assurera la gestion des lignes ajoutées ou enlevées, mais il appellera aussi l'observateur qui pourra réaliser d'autres tâches.</p>

<p>L'observateur du constructeur d'arbres implémente l'interface <a href="http://www.xulplanet.com/references/xpcomref/ifaces/nsIXULTreeBuilderObserver.html">nsIXULTreeBuilderObserver</a> et il doit être attaché au constructeur d'arbres en utilisant la méthode <code>addObserver</code> de la propriété <code>builder</code>. Vous pouvez ajouter plus d'un observateur si nécessaire, et vous pouvez en supprimer grâce à la méthode <code>removeObserver</code>.</p>

<p>L'observateur est toujours invoqué avant que l'opération appropriée soit exécutée. Par exemple, la méthode <code>onToggleOpenState</code> de n'importe quel observateur sera appelée avant que l'item de l'arbre ne soit ouvert. Après que les observateurs aient fini, le constructeur d'arbres ouvre la ligne et ajoute toutes les lignes filles dedans.</p>

<p class="note">Notez que vous ne pouvez pas annuler l'opération à partir d'un observateur.</p>

<p>Les quelques fonctions utiles des observateurs sont les fonctions de rappel du glisser-déposer qui traitent le cas d'un item déplacé vers un arbre. Elles rendent la gestion du glisser-déposer vers un arbre particulièrement simple. Tout ce que vous avez à faire est d'implémenter deux méthodes, <code>canDrop</code> et <code>onDrop</code>. Notez qu'avec Firefox 1.0 (Mozilla 1.7) et précédente, les fonctions glisser-déposer sont légèrement différentes. Pour ces versions, trois fonctions étaient utilisées, <code>canDropOn</code>, <code>canDropBeforeAfter</code> et <code>onDrop</code>. Les deux fonctions 'can' ont été combinées en une seule avec un argument supplémentaire. Si vous désirez supporter les anciennes et les nouvelles versions, vous pouvez implémenter toutes ces fonctions dans un observateur en partageant le code si nécessaire.</p>

<p>L'observateur d'arbre reçoit les évènements relatifs au glisser-déposer à trois endroits&nbsp;: au dessus d'un conteneur de ligne, avant une ligne, et après une ligne. Ces trois cas vous permettent d'accéder à une plus grande souplesse de gestion du glisser-déposer. Par exemple, dans certaines situations, vous aurez à glisser quelque chose vers un type dossier d'une ligne. Dans d'autres situations, vous souhaiterez permettre à des items d'être déplacés entre (avant ou après) des lignes. Il peut s'agir d'une situation où vous déplacez des items d'un point à un autre de l'arbre, comme par exemple le déplacement d'un marque-page d'un endroit vers un autre. Le composant graphique de l'arbre dessinera une petite ligne entre les lignes lors du déplacement. Tout ce que vous avez à faire est d'ajouter un observateur pour le constructeur d'arbre qui retourne <var>true</var> pour la méthode <code>canDrop</code>. Notez que le cas du déplacement n'est seulement permis qu'au dessus de conteneurs, mais pas de lignes ordinaires.</p>

<pre><code>var treeBuilderObserver = {
  canDropBeforeAfter : function(idx, orient) { return false; },
  canDropOn : function(idx, orient) { return true; },
  canDrop : function(idx, orient) { return !orient; },
  onDrop : function(idx, orient) {
    // faire quelque chose ici
  },
};
tree.builder.addObserver(treeBuilderObserver);</code></pre>

<p>Cet observateur implémente à la fois les anciennes et les nouvelles méthodes et ne peut servir que pour des glisser sur des lignes. La méthode <code>canDropBeforeAfter</code> retourne <var>false</var> puisque nous ne voulons pas déposer des items avant et après des lignes. La méthode <code>canDropOn</code> retourne <var>true</var>. La méthode <code>canDrop</code> de Mozilla&nbsp;1.8 teste l'orientation et retourne son opposé. Elle fonctionne comme si la valeur 'au dessus' est <var>0</var> et les valeurs 'entre' sont <var>-1</var> et <var>1</var>. Évidemment, ce code est bien plus simple qu'il ne serait en réalité -- nous devrions tester le contenu qui est en train d'être glissé pour être certain qu'il soit compatible avec l'arbre, ou ne permettre de déposer que sur des lignes spécifiques. Les méthodes pour déposer sont fournies avec un argument index pouvant servir aux tests.</p>
