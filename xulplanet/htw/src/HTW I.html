
<p>Les gabarits (ou templates) sont apparement difficilement compréhensibles pour beaucoup. Malheureusement, il y a beaucoup de choses à apprendre pour les utiliser&nbsp;: RDF, la syntaxe de requète, et des fonctionnalités XUL supplémentaires. Le manque de messages d'erreurs ou de log, rend les choses doublement difficiles.</p>

<p>Peut être que les templates seraient plus facile si les développeurs comprenaient la façon dont les templates fonctionnent. C'est la première partie d'une longue serie d'articles sur ce sujet.</p>

<p>Pour commencer, un template XUL est une sorte de production de blocs de contenu pour chaque résultat issue d'une requète ou assimilée. Une bonne analogie sont les résultats d'une requêtes de base de données. Pour chaque resultat retourné par la requête, génerer un contenu. La syntaxe des templates permet pour différentes rêgles de générer different contenus basés sur des critères particuliers, comme définir des valeurs d'attributs à partir des résultats retournés. D'autres systèmes appelle cela le "databinding". Effectivment, les templates XUL est le moyen pour XUL de faire du "databinding". Cependant, avaec un template, il y a deux restrictions. Premièrement, vous ne pouvez générer du contenu qu'à partir des résultats d'une requète. Vous ne pouvez pas prendre juste une seul donnée et l'assigner à un attribut, puisque les templates sont conçus pour les blocs de données répétitifs. Deuxièmement, vous pouvez utiliser uniquement les sources de données RDF. Ces restrictions devraient disparaître dans le futur.</p>

<p>En XUL, la source de données RDF est spécifiées en plaçant l'attribut "datasources" sur un élément. Quand le parser XUL voit un élément avec cet attribut, il instancie un constructeur de template et l'attache à l'élément. Il s'attend à ce qu'il y ait un <template> à l'interieur de l'élément. Le constructeur de template charge la source de donnée, exécute la requête, et génère le contenu pour chaque résultat. Le contenu est inséré dans le contenu XUL comme si vous l'aviez placé vous même. Voici un exemple.</p>

<pre><code>&lt;vbox datasources="http://www.xulplanet.com/ds/sample.rdf"&gt;</code></pre>

<p>Cet exemple spécifie la source de donnée&nbsp;: <var>http://www.xulplanet.com/ds/sample.rdf</var>.</p>

<p>Le constructeur de template charge la source de donnée en utilisant le service RDF, de la même façon que vous auriez créer la source de donnée directement à travers le service RDF. La source de donnée est chargée via son URL. Certaines sources de données RDF sont fournies avec Mozilla (leur URL commençent par "rdf:"). Elles sont cependant chargées comme n'importe quel autre URL. Si la source de donnée est déjà chargée et est dans le cache, le constructeur de template peut commençer le travail. Sinon, il n'y a rien à faire jusqu'à ce que les données soient chargées. Ce n'est pas exactement vrai. Le service RDF commençent à charger la source de donnée en tâche de fond, et le constucteur de template commençe tout de même le processus de construction. Naturellement, tant qu'il n'y a pas encore de données, aucun résultats ne sera disponible, donc le constructeur ne génère rien.</p>

<p>Dés que des données commençent à arriver, le constructeur de template scanne les informations pour voir si des résultats peuvent être créés. Si c'est le case, du contenu peut être généré. Sinon, rien n'est généré pour l'instant. Une chose interressante à noter est que, du fait de la nature du processus d'analyse du RD, le constructeur génère les résultats et construits le contenu incrementallement, pendant que les données arrivent. Bien sûr, si les données arrivent tellement vite à partir du réseau que vous ne vous en rendez pas compte. Si la source de données est déjà chargée, le constructeur génère le contenu en une seule étape, bien que cela ne soit pas complètement vrai comme nous le verrons plus tard.</p>

<p>Le constructeur de template peut aussi utiliser de multiple sources de données, qui sont combinées entre elles en une seule source de données, comme si elles étaient à l'origine dans une seule source de données. Un objet d'interface nsIRDFCompositeDataSource est utilisé pour cet usage. Vous pouvez avoir cette source de donnée composite dans un script en utilisant la propriété "database" de l'élément, si vous voulez ajouter ou enlever des sources de données.</p>

<p>Comme il est mentionné, le constructeur de template charge les sources de données en passant les URLs au service RDF. Cependant, un URL spécial, rdf:null, est utilisé pour indiquer que vous n'avez pas de sources de données, ou alors indiquer une source de donnée vide. Une source de donnée composite sera tout de même créée, mais aucune source de donnée ne sera ajoutée. C'est utilisé quand vous avez besoin de spécifier une source de donnée dynamiquement avec un script.</p>

<p>De plus, pour les fichiers XUL du chrome (comme les extensions), la source de donnée rdf:local-store est toujours incluse dans le composite. Le "local-store" (NDT: literalement, stockage local), est une source de donnée qui est habituellement utilisée pour stocker les informations d'états, comme les tailles des fenêtres, la liste des colonnes affichées dans un arbre, ou la liste des items d'arbre qui sont ouverts. Vous pouvez interroger pour n'importe quelle donnée dans un template, bien que cela soit rarement fait.</p>

<p>Quand de multiples sources de données sont utilisées, le RDF est combiné comme si c'était une grande source de données. Cela signifie qu'une requête de template peut récupérer les données de n'importe quelle de ces sources de données. Cette combinaison est souvent appelée "agrégation". Cela peut être une fonctionnalité interressante et fonctionne indépendament de la source. Par exemple, vous pourriez utiliser la source de donnée interne des signets, qui contient les marques pages de l'utilisateur, et utiliser votre propre source de donnée pour ajouter des données personnalisées à ces marques pages.</p>

<pre><code>&lt;vbox datasources="rdf:bookmarks http://www.xulplanet.com/ds/sample.rdf"&gt;</code></pre>

<hr />

<p>Dans la section suivante, nous aborderons l'attribut <code class="attribut">ref</code>.</p>
