
<p>Un gabarit XUL est construit sur la base d'une série de règles. Chaque règle contient deux choses, un jeu d'instructions pour naviguer à travers un graphe RDF et du contenu XUL à générer. A partir d'un point donné, le constructeur de gabarit va évaluer les instructions de navigation pour chacune des règles et générera une série de données intermédiaires correspondant à ces règles. Le contenu correspondant sera ensuite généré. Le mécanisme est en fait plus compliqué, mais c'est l'idée générale.</p>

<p>Il existe deux syntaxes pour la déclaration des règles, la syntaxe simplifiée et la syntaxe étendue (ou complète). Comme son nom l'indique, la syntaxe simplifiée est plus simple mais est limitée dans le type de données qu'elle peut parcourir. Elle peut être utilisée pour parcourir un et un seul arc (ou flèche) dans le graphe RDF. La syntaxe étendue permet de naviguer n'importe où dans le graphe. La syntaxe simplifiée sera presque toujours utilisée pour parcourir une série d'enfants d'un conteneur RDF tel qu'un Seq. Un élément Seq RDF est un conteneur dont les enfants sont disposés dans un ordre spécifique. Le gabarit générera ces résultats dans cet ordre.</p>

<p>La syntaxe simplifiée est une sous version de la syntaxe étendue, et en tant que telle, elle peut être réécrite en utilisant la syntaxe étendue. En fait, le constructeur de gabarit se charge de convertir la règle simplifiée dans une syntaxe étendue avant de l'utiliser. Quelque soit la syntaxe que vous préférez, vous devez utiliser celle qui vous semble la plus naturelle. Notez toutefois que la syntaxe simplifiée utilise une légère optimisation lors de l'emploi de plusieurs règles contrairement à la syntaxe étendue. Nous verrons cela dans le détail plus tard.</p>

<p>Chaque règle est déclarée en utilisant la balise <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/rule">rule</a></code> que vous placerez directement à l'intérieur de l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/template">template</a></code>. Vous pouvez avoir autant de règles que vous le désirez ou une seule. Lors de l'emploi de la syntaxe simplifiée, vous pouvez omettre l'élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/rule">rule</a></code> puisque vous ne pouvez en utiliser qu'une seule. La syntaxe étendue nécessite toutefois toujours un élément <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/rule">rule</a></code>.</p>

<p>Voici le squelette externe de la syntaxe du gabarit à ce stade&nbsp;:</p>

<pre><code>&lt;vbox datasources="http://www.xulplanet.com/ds/sample.rdf"
         ref="http://www.xulplanet.com/rdf/A" flex="1"&gt;
  &lt;template&gt;
    &lt;rule&gt;
      -- Le contenu de la règle se place ici --
    &lt;/rule&gt;
    &lt;rule&gt;
      -- Le contenu de la règle se place ici --
    &lt;/rule&gt;
  &lt;/template&gt;
&lt;/vbox&gt;</code></pre>

<p>Lorsque le constructeur de gabarit débute son processus, et après le chargement de la source de données, il commence à compiler les règles. Cette étape implique de travailler à travers les règles et de les lancer des processus internes. Ainsi, la modification dynamique des éléments <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/rule">rule</a></code> n'aura aucun effet. Toutefois, la reconstruction du gabarit (en utilisant la méthode <code>builder.rebuild</code>) recompilera les règles et réappliquera de nouveau le gabarit. Cela signifie que vous pouvez modifier les règles grâce aux méthodes du DOM, reconstruire le gabarit, et obtenir des résultats différents.</p>


<p>Une fois que le constructeur de gabarits a compilé les règles, l'analyse des règles et la génération du contenu peut commencer. Le constructeur de gabarits génère le contenu de manière paresseuse, c'est-à-dire qu'il ne réalise un traitement que lorsque c'est nécessaire, et qu'il ne continue que si c'est nécessaire. Considérons par exemple le cas suivant&nbsp;:</p>

<pre><code>&lt;vbox datasources="http://www.xulplanet.com/ds/sample.rdf"
         ref="http://www.xulplanet.com/rdf/A" hidden="true"&gt;
  &lt;template&gt;
    ...
  &lt;/template&gt;
&lt;/vbox&gt;</code></pre>

<p>La <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> est masquée comme indiqué par l'attribut <code class="attribut">hidden</code>. Comme tout le contenu pouvant être généré ne pourrait pas être affiché, le constructeur de gabarits ne fait rien, en repoussant le travail à plus tard. Si maintenant, vous affichez la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> en mettant l'état <var>false</var> sur l'attribut <code class="attribut">hidden</code>, le constructeur de gabarits sera appelé et le contenu généré.</p>

<p>Est-ce que cela signifie que les gabarits ne peuvent pas être utilisés dans des endroits cachés de l'interface utilisateur&nbsp;? Non, vous pouvez toujours encore le faire. La modification de l'état <code class="attribut">hidden</code> d'un élément n'est pas le seul moyen pour provoquer la génération du contenu. L'appel d'une API DOM qui nécessite de récupérer le contenu généré, va relancer le constructeur de gabarits. Par exemple, l'appel du code suivant sur la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> masquée ci-dessus va mettre en route le constructeur de gabarits&nbsp;:</p>

<pre><code>var length = vbox.childNodes.length;</code></pre>

<p>Cette requête demandant le nombre d'enfants de la <code class="tag"><a href="http://xulfr.org/wiki/Reference/Xul/vbox">vbox</a></code> va obliger le  constructeur de gabarits à traiter les règles et à générer le contenu. Ensuite, le nombre correct peut être retourné.</p>

<p>Tout cela est transparent pour le développeur XUL. Le moment où le constructeur de gabarits commence la génération est déterminé automatiquement sans rien faire de spécial. Cependant, il y a deux cas ou le contenu n'est pas généré automatiquement&nbsp;: les menus et les items d'un arbre.</p>

<p>Le contenu à l'intérieur d'un menu n'est généré que quand le menu est ouvert. Ce fonctionnement est logique puisque l'utilisateur ne peut voir le contenu tant qu'il ne l'a pas ouvert. Toutefois, cela signifie aussi que l'utilisation de l'API DOM, telle que d'essayer de connaître le nombre de noeuds enfants comme ci-dessus, n'inclura pas les items générés avant que le menu ne soit ouvert. Il s'agit d'une distinction importante. Elle signifie que vous ne pouvez pas espérer obtenir les items du menu généré avant que celui-ci ne soit ouvert. Un principe semblable s'applique aux items enfants d'un arbre. Les branches filles ne sont générées qu'une fois que l'utilisateur appuie sur le symbole d'exploration (<abbr title="Note du traducteur">NdT</abbr>&nbsp;: twisty) pour ouvrir le conteneur, ou qu'un script n'ouvre une ligne.</p>

<p>La génération paresseuse est pratique pour les menus et les arbres notamment lors de traitements récursifs. Il serait trop long de générer une sortie pour chaque item d'un arbre, même ceux qui ne sont pas affichés, donc le constructeur de gabarits évite donc de le faire.</p>

<p>Le constructeur de gabarits est même plus paresseux que cela. Si le contenu généré contient des éléments masqués, ces éléments enfants ne seront pas générés tant ce que n'est pas nécessaire. Quand il construit le contenu, le constructeur parcourt les noeuds de l'arbre, en ne copiant et en ne construisant que ce qui est nécessaire.</p>
