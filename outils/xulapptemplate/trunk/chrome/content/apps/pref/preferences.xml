<?xml version="1.0"?>

<!DOCTYPE bindings SYSTEM "chrome://global/locale/preferences.dtd">

<bindings id="preferencesBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">


  <binding id="preferences">
    <implementation implements="nsIObserver">
      <method name="observe">
        <parameter name="aSubject"/>
        <parameter name="aTopic"/>
        <parameter name="aData"/>
        <body>
        <![CDATA[
          for (var i = 0; i < this.childNodes.length; ++i) {
            var preference = this.childNodes[i];
            if (preference.name == aData) {
              preference.value = preference.valueFromPreferences;
              this.fireChangedEvent(preference);
            }
          }
        ]]>
        </body>
      </method>
      
      <method name="fireChangedEvent">
        <parameter name="aPreference"/>
        <body>
        <![CDATA[
          // Value changed, synthesize an event
          try {
            var event = document.createEvent("Events");
            event.initEvent("change", false, true);
            aPreference.dispatchEvent(event);
            if (aPreference.hasAttribute("onchange"))
              (new Function ("event", aPreference.getAttribute("onchange")))(event);
          }
          catch (e) {
            dump(e);
          }
        ]]>
        </body>
      </method>
      
      <field name="service">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefService);
      </field>
      <field name="rootBranch">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefBranch);
      </field>
      <field name="defaultBranch">
        this.service.getDefaultBranch("");
      </field>
      <field name="rootBranchInternal">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefBranchInternal);
      </field>
    </implementation>
  </binding>

  <binding id="preference">
    <implementation>
      <constructor>
      <![CDATA[
        this.preferences.rootBranchInternal
            .addObserver(this.name, this.preferences, false);
        // In non-instant apply mode, we must try and use the last saved state
        // from any previous opens of a child dialog instead of the value from
        // preferences, to pick up any edits a user may have made. 
        if (document.documentElement.type == "child" && 
            !this.instantApply && window.opener) {
          var pdoc = window.opener.document;
          var lastStatePref = pdoc.getElementById(window.location.href + "#" + this.id);
          this._setValue(lastStatePref ? lastStatePref.value 
                                       : this.valueFromPreferences, false);
        }
        else
          this._setValue(this.valueFromPreferences, false);
      ]]>
      </constructor>
      <destructor>
        this.preferences.rootBranchInternal
            .removeObserver(this.name, this.preferences);
      </destructor>
      
      <property name="instantApply">
        <getter>
          return this.getAttribute("instantApply") == "true" || document.documentElement.instantApply;
        </getter>
      </property>

      <property name="preferences" onget="return this.parentNode"/>
      <property name="name" onget="return this.getAttribute('name');">
        <setter>
          if (val == this.name)
            return val;
            
          this.preferences.rootBranchInternal
              .removeObserver(this.name, this.preferences);
          this.setAttribute('name', val);
          this.preferences.rootBranchInternal
              .addObserver(val, this.preferences, false);
              
          return val;
        </setter>
      </property>
      <property name="type" onget="return this.getAttribute('type');"
                            onset="this.setAttribute('type', val); return val;"/>
      <property name="inverted" onget="return this.getAttribute('inverted') == 'true';"
                                onset="this.setAttribute('inverted', val); return val;"/>
      <property name="readonly" onget="return this.getAttribute('readonly') == 'true';"
                                onset="this.setAttribute('readonly', val); return val;"/>

      <field name="_value">null</field>
      <method name="_setValue">
        <parameter name="aValue"/>
        <parameter name="aUpdate"/>
        <body>
        <![CDATA[
          if (aUpdate && this.value != aValue) {
            this._value = aValue;
            if (this.instantApply)
              this.valueFromPreferences = aValue;
            this.preferences.fireChangedEvent(this);
          }
          else if (!aUpdate) {
            this._value = aValue;
            this.updateElements();
          }
          return aValue;
        ]]>
        </body>
      </method>
      
      <property name="value" onget="return this._value" onset="return this._setValue(val, true);"/>
      
      <property name="locked">
        <getter>
          return this.preferences.rootBranch.prefIsLocked(this.name);
        </getter>
      </property>
      
      <property name="disabled">
        <getter>
          return this.getAttribute("disabled") == "true";
        </getter>
        <setter>
        <![CDATA[
          if (val) 
            this.setAttribute("disabled", "true");
          else
            this.removeAttribute("disabled");

          var elements = document.getElementsByAttribute("preference", this.id);
          for (var i = 0; i < elements.length; ++i) {
            elements[i].disabled = val;
            
            var labels = document.getElementsByAttribute("control", elements[i].id);
            for (var j = 0; j < labels.length; ++j)
              labels[j].disabled = val;
          }
            
          return val;
        ]]>
        </setter>
      </property>
      
      <property name="tabIndex">
        <getter>
          return parseInt(this.getAttribute("tabindex"));
        </getter>
        <setter>
        <![CDATA[
          if (val) 
            this.setAttribute("tabindex", val);
          else
            this.removeAttribute("tabindex");

          var elements = document.getElementsByAttribute("preference", this.id);
          for (var i = 0; i < elements.length; ++i) {
            elements[i].tabIndex = val;
            
            var labels = document.getElementsByAttribute("control", elements[i].id);
            for (var j = 0; j < labels.length; ++j)
              labels[j].tabIndex = val;
          }
            
          return val;
        ]]>
        </setter>
      </property>

      <property name="hasUserValue">
        <getter>
          return this.preferences.rootBranch.prefHasUserValue(this.name);
        </getter>
      </property>
      
      <method name="reset">
        <body>
          this.preferences.rootBranch.clearUserPref(this.name);
        </body>
      </method>

      <field name="_useDefault">false</field>      
      <property name="defaultValue">
        <getter>
        <![CDATA[
          this._useDefault = true;
          var val = this.valueFromPreferences;
          this._useDefault = false;
          return val;
        ]]>
        </getter>
      </property>
      
      <property name="_branch">
        <getter>
          return this._useDefault ? this.preferences.defaultBranch : this.preferences.rootBranch;
        </getter>
      </property>
      
      <field name="batching">false</field>
      
      <property name="valueFromPreferences">
        <getter>
        <![CDATA[
          try {
            // Force a resync of value with preferences.
            switch (this.type) {
            case "int":
              return this._branch.getIntPref(this.name);
            case "bool":
              var val = this._branch.getBoolPref(this.name);
              return this.inverted ? !val : val;
            case "string":
              return this._branch.getCharPref(this.name);
            case "wstring":
              return this._branch
                         .getComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString)
                         .data;
            case "unichar":
              var pref = Components.classes["@mozilla.org/preferences;1"] 
                                   .getService(Components.interfaces.nsIPref);
              return pref.CopyUnicharPref(this.name);
            case "file":
              var f = this._branch
                          .getComplexValue(this.name, Components.interfaces.nsILocalFile);
              return f;
            }
          }
          catch (e) { }
          return null;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (this.readonly || this.valueFromPreferences == val)
            return val;
            
          // Force a resync of preferences with value.
          switch (this.type) {
          case "int":
            this.preferences.rootBranch.setIntPref(this.name, val);
            break;
          case "bool":
            this.preferences.rootBranch.setBoolPref(this.name, this.inverted ? !val : val);
            break;
          case "string":
            this.preferences.rootBranch.setCharPref(this.name, val);
            break;
          case "wstring":
            var pls = Components.classes["@mozilla.org/pref-localizedstring;1"]
                                .createInstance(Components.interfaces.nsIPrefLocalizedString);
            pls.data = val;
            this.preferences.rootBranch
                .setComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString, pls);
            break;
          case "unichar":
            var pref = Components.classes["@mozilla.org/preferences;1"] 
                                 .getService(Components.interfaces.nsIPref);
            pref.SetUnicharPref(this.name, val);
            break;
          case "file":
            var lf;
            if (typeof(val) == "string") {
              lf = Components.classes["@mozilla.org/file/local;1"]
                             .createInstance(Components.interfaces.nsILocalFile);
              lf.persistentDescriptor = val;
              if (!lf.exists())
                lf.initWithPath(val);
            }
            else 
              lf = val.QueryInterface(Components.interfaces.nsILocalFile);
            this.preferences.rootBranch
                .setComplexValue(this.name, Components.interfaces.nsILocalFile, lf);
            break;
          }
          if (!this.batching)
            this.preferences.service.savePrefFile(null);
          return val;
        ]]>
        </setter>
      </property>
      
      <method name="setElementValue">
        <parameter name="aElement"/>
        <body>
        <![CDATA[
          if (this.locked)
            aElement.disabled = true;

          if (!this.isElementEditable(aElement))
            return;

          var rv = undefined;
          if (aElement.hasAttribute("onsyncfrompreference")) {
            // Value changed, synthesize an event
            try {
              var event = document.createEvent("Events");
              event.initEvent("preferenceread", false, true);
              var f = new Function ("event", 
                                    aElement.getAttribute("onsyncfrompreference"));
              rv = f(event);
            }
            catch (e) {
              dump(e);
            }
          }
          var val = rv !== undefined ? rv : (this.instantApply ? this.valueFromPreferences : this.value);

          /**
           * Initialize a UI element property with a value. Handles the case 
           * where an element has not yet had a XBL binding attached for it and
           * the property setter does not yet exist by setting the same attribute
           * on the XUL element using DOM apis and assuming the element's 
           * constructor or property getters appropriately handle this state. 
           */
          function setValue(element, attribute, value) {
            if (attribute in element) 
              element[attribute] = value;
            else
              element.setAttribute(attribute, value);
          }
          if (aElement.localName == "checkbox")
            setValue(aElement, "checked", val);
          else if (aElement.localName == "colorpicker")
            setValue(aElement, "color", val);
          else if (aElement.localName == "textbox") {
            // XXXmano Bug 303998: Avoid a caret placement issue if either the
            // preference observer or its setter calls updateElements as a result
            // of the input event handler.
            if (aElement.value !== val)
              setValue(aElement, "value", val);
          }
          else
            setValue(aElement, "value", val);
        ]]>
        </body>
      </method>

      <method name="getElementValue">
        <parameter name="aElement"/>
        <body>
        <![CDATA[
          if (aElement.hasAttribute("onsynctopreference")) {
            // Value changed, synthesize an event
            try {
              var event = document.createEvent("Events");
              event.initEvent("preferencewrite", false, true);
              var f = new Function ("event", 
                                    aElement.getAttribute("onsynctopreference"));
              var rv = f(event);
              if (rv !== undefined) 
                return rv;
            }
            catch (e) {
              dump(e);
            }
          }
          
          /**
           * Read the value of an attribute from an element, assuming the 
           * attribute is a property on the element's node API. If the property
           * is not present in the API, then assume its value is contained in
           * an attribute, as is the case before a binding has been attached.
           */
          function getValue(element, attribute) {
            if (attribute in element)
              return element[attribute];
            return element.getAttribute(attribute);
          }
          if (aElement.localName == "checkbox")
            var value = getValue(aElement, "checked");
          else if (aElement.localName == "colorpicker")
            value = getValue(aElement, "color");
          else
            value = getValue(aElement, "value");

          switch (this.type) {
          case "int":
            var intValue = parseInt(value, 10) + '';
            return intValue != "NaN" ? intValue : 0;
          case "bool":
            return typeof(value) == "boolean" ? value : value == "true";
          }
          return value;
        ]]>
        </body>
      </method>
      
      <method name="isElementEditable">
        <parameter name="aElement"/>
        <body>
        <![CDATA[
          switch (aElement.localName) {
          case "checkbox":
          case "colorpicker":
          case "radiogroup":
          case "textbox":
          case "listitem":
          case "listbox":
          case "menulist":
            return true;
          }
          return aElement.getAttribute("preference-editable") == "true";
        ]]> 
        </body>
      </method>
      
      <method name="updateElements">
        <body>
        <![CDATA[
          // This "change" event handler tracks changes made to preferences by 
          // sources other than the user in this window. 
          var elements = document.getElementsByAttribute("preference", this.id);         
          for (var i = 0; i < elements.length; ++i) 
               this.setElementValue(elements[i]);
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      <handler event="change">
        this.updateElements();
      </handler>
    </handlers>
  </binding>

  <binding id="prefwindow"
           extends="chrome://global/content/bindings/dialog.xml#dialog">
    <resources>
      <stylesheet src="chrome://apps/skin/pref/preferences.css"/>
    </resources>
    <content xul:dlgbuttons="accept,cancel" xul:persist="lastSelected screenX screenY width height"
             xul:closebuttonlabel="&preferencesCloseButton.label;"
             xul:closebuttonaccesskey="&preferencesCloseButton.accesskey;"
             xul:title="&preferencesDefaultTitleWin.title;">

      <xul:hbox flex="1" class="prefwindow-content-box">
        <xul:radiogroup anonid="selector" class="paneSelector multi-prefs"
                        xmlns:xhtml2="http://www.w3.org/TR/xhtml2"
                        xmlns:wairole="http://www.w3.org/2005/01/wai-rdf/GUIRoleTaxonomy#"
                        xmlns:waistate="http://www.w3.org/2005/01/wai-rdf/GUIStateTaxonomy#"
                        xhtml2:role="wairole:list"/> <!-- Expose to accessibility APIs as a list -->
       <xul:vbox flex="1" class="prefwindow-right-box">
        <xul:dialogheader anonid="header" class="multi-prefs"/>
        <xul:hbox flex="1" class="paneDeckContainer">
          <xul:deck anonid="paneDeck" flex="1">
            <children includes="prefpane"/>
          </xul:deck>
        </xul:hbox>
       </xul:vbox>
      </xul:hbox>
      <xul:hbox anonid="dlg-buttons" class="prefWindow-dlgbuttons" pack="end">
        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
        <xul:spacer anonid="spacer" flex="1" hidden="true"/>
        <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
        <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
        <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
      </xul:hbox>
      <xul:hbox>
        <children/>
      </xul:hbox>
      <xul:keyset>
        <xul:key anonid="keyClose" key="&windowClose.key;" modifiers="accel" oncommand="window.close();"/>
      </xul:keyset>
      </content>

    <implementation>

      <constructor>
      <![CDATA[

        if (this.type != "child") {
          var psvc = Components.classes["@mozilla.org/preferences-service;1"]
                               .getService(Components.interfaces.nsIPrefBranch);
          this.instantApply = psvc.getBoolPref("browser.preferences.instantApply");
          if (this.instantApply) {
            var docElt = document.documentElement;
            var acceptButton = docElt.getButton("accept");
            acceptButton.hidden = true;
            var cancelButton  = docElt.getButton("cancel");
            // morph the Cancel button into the Close button
            cancelButton.setAttribute ("icon", "close");
            cancelButton.label = docElt.getAttribute("closebuttonlabel");
            cancelButton.accesskey = docElt.getAttribute("closebuttonaccesskey");
          }
          else {
            // No Cmd+W in non-instant-apply preferences windows
            var keyClose = document.getAnonymousElementByAttribute(this, "anonid", "keyClose");
            keyClose.parentNode.removeChild(keyClose);
          }
        }
        else {
          // No Cmd+W in child dialogs
          var keyClose = document.getAnonymousElementByAttribute(this, "anonid", "keyClose");
          keyClose.parentNode.removeChild(keyClose);          
        }
        var panes = this.preferencePanes;

        var lastPane = null;
        if (this.lastSelected) {
          lastPane = document.getElementById(this.lastSelected);
          if (!lastPane) {
            this.lastSelected = null;
          }
        }

        var paneToLoad;
        if ("arguments" in window && window.arguments[0] && document.getElementById(window.arguments[0]))
          paneToLoad = document.getElementById(window.arguments[0]);
        else if (lastPane)
          paneToLoad = lastPane;
        else
          paneToLoad = panes[0];


        for (var i = 0; i < panes.length; ++i) {
          this._makePaneButton(panes[i]);
          if (panes[i].loaded) {
            // Inline pane content, fire load event to force initialization.
            this._fireEvent("paneload", panes[i]);
          }
        }
        this.showPane(paneToLoad);

        if (panes.length == 1) {
            this._selector.setAttribute("collapsed", "true");
         // this._header.setAttribute("collapsed", "true");
        }

      ]]>
      </constructor>

      <field name="instantApply">false</field>
      
      <property name="preferencePanes"
                onget="return this.getElementsByTagName('prefpane');"/>

      <property name="type" onget="return this.getAttribute('type');"/>
      <property name="_paneDeck"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'paneDeck');"/>
      <property name="_selector"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'selector');"/>
      <property name="_header"
                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'header');"/>
      <property name="lastSelected" 
                onget="return this.getAttribute('lastSelected');">
        <setter>
          this.setAttribute("lastSelected", val); 
          document.persist(this.id, "lastSelected");
          return val;
        </setter>          
      </property>
      <field name="currentPane">null</field>
      
      <method name="_makePaneButton">
        <parameter name="aPaneElement"/>
        <body>
        <![CDATA[
          var radio = document.createElement("radio");
          radio.setAttribute("pane" , aPaneElement.id);
          radio.setAttribute("label", aPaneElement.label);
         
          // Expose preference group choice to accessibility APIs as an unchecked list item
          // The parent group is exposed to accessibility APIs as a list
          /* XXXDavid 
          radio.setAttributeNS("http://www.w3.org/TR/xhtml2", "role", "wairole:listitem");
          radio.setAttributeNS("http://www.w3.org/2005/01/wai-rdf/GUIStateTaxonomy#", "checked", "false");
           */
          
          if (aPaneElement.image)
            radio.setAttribute("src", aPaneElement.image);

          if(aPaneElement.style.listStyleImage)
             radio.style.listStyleImage = aPaneElement.style.listStyleImage;

          this._selector.appendChild(radio);
          return radio;
        ]]>
        </body>
      </method>

      <method name="showPane">
        <parameter name="aPaneElement"/>
        <body>
        <![CDATA[
          this._selector.selectedItem = document.getAnonymousElementByAttribute(this, "pane", aPaneElement.id);
          if (!aPaneElement.loaded) {
            function OverlayLoadObserver(aPane)
            {
              this._pane = aPane;
            }
            OverlayLoadObserver.prototype = { 
              _outer: this,
              observe: function (aSubject, aTopic, aData) 
              {
                this._pane.loaded = true;
                this._outer._fireEvent("paneload", this._pane);
                this._outer._selectPane(this._pane);
              }
            };
            
            var obs = new OverlayLoadObserver(aPaneElement);
            document.loadOverlay(aPaneElement.src, obs);
          }
          else
            this._selectPane(aPaneElement);
        ]]>
        </body>
      </method>
      
      <method name="_fireEvent">
        <parameter name="aEventName"/>
        <parameter name="aTarget"/>
        <body>
        <![CDATA[
          // Panel loaded, synthesize a load event. 
          try {
            var event = document.createEvent("Events");
            event.initEvent(aEventName, false, true);
            var cancel = !aTarget.dispatchEvent(event);
            if (aTarget.hasAttribute("on" + aEventName)) {
              var fn = new Function ("event", aTarget.getAttribute("on" + aEventName));
              var rv = fn.call(aTarget, event);
              if (rv == false)
                cancel = true;
            }
            return !cancel;  
          }
          catch (e) { 
            dump(e);
          }
          return false;
        ]]>
        </body>
      </method>
      
      <field name="_initialized">false</field>
      <method name="_selectPane">
        <parameter name="aPaneElement"/>
        <body>
        <![CDATA[

          // Find this pane's index in the deck and set the deck's 
          // selectedIndex to that value to switch to it.
          var prefpanes = this.preferencePanes;
          for (var i = 0; i < prefpanes.length; ++i) {
            if (prefpanes[i] == aPaneElement) 
            {
              this._paneDeck.setAttribute("selectedIndex", i);
              this._header.setAttribute("title",aPaneElement.label);

              if (this.type != "child")
              {
                var oldPane = this.lastSelected ? document.getElementById(this.lastSelected) : this.preferencePanes[0];
                oldPane.selected = !(aPaneElement.selected = true);
                if (!this._initialized || oldPane.id != aPaneElement.id) {
                  this.lastSelected = aPaneElement.id;
                  this.currentPane  = aPaneElement;
                  this._initialized = true;
                }
              }
              break;
            }
          }

          var helpButton = document.documentElement.getButton("help");
          if (aPaneElement.hasAttribute("helpURI"))
            helpButton.hidden = false;
          else
            helpButton.hidden = true;
        ]]>
        </body>
      </method>
            

      <method name="addPane">
        <parameter name="aPaneElement"/>
        <body>
        <![CDATA[
          this.appendChild(aPaneElement);
          
          // Set up pane button
          this._makePaneButton(aPaneElement);
        ]]>
        </body>
      </method>
      
      <method name="openSubDialog">
        <parameter name="aURL"/>
        <parameter name="aFeatures"/>
        <parameter name="aParams"/>
        <body>
          return openDialog(aURL, "", "modal,centerscreen" + (aFeatures != "" ? ("," + aFeatures) : ""), aParams);
        </body>
      </method>
      
      <method name="openWindow">
        <parameter name="aWindowType"/>
        <parameter name="aURL"/>
        <parameter name="aFeatures"/>
        <parameter name="aParams"/>
        <body>
          var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                             .getService(Components.interfaces.nsIWindowMediator);
          var win = aWindowType ? wm.getMostRecentWindow(aWindowType) : null;
          if (win) {
            if ("initWithParams" in win)
              win.initWithParams(aParams);
            win.focus();
          }
          else {
            var features = "resizable,dialog=no,centerscreen" + (aFeatures != "" ? ("," + aFeatures) : "");
            var parentWindow = (this.instantApply || !window.opener || window.opener.closed) ? window : window.opener;
          //var parentWindow = this.instantApply ? window : window.opener;
            win = parentWindow.openDialog(aURL, "_blank", features, aParams);
          }
          return win;
        </body>
      </method>
      
      // copied from contextHelp.js
      // Locate existing help window for this helpFileURI.
      <method name="locateHelpWindow">
        <parameter name="helpFileURI"/>
        <body>
        <![CDATA[
          const wm = Components.classes['@mozilla.org/appshell/window-mediator;1']
                               .getService(Components.interfaces.nsIWindowMediator);
          const iterator = wm.getEnumerator("mozilla:help");
          var topWindow = null;
          var aWindow;

          // Loop through help windows looking for one with selected helpFileURI
          while (iterator.hasMoreElements()) {
            aWindow = iterator.getNext();
            if (aWindow.getHelpFileURI() == helpFileURI)
              topWindow = aWindow;
          }
          return topWindow;
        ]]>
        </body>
      </method>
      
      // copied from contextHelp.js
      // Opens up the Help Viewer with the specified topic and helpFileURI.
      <method name="openHelp">
        <parameter name="topic"/>
        <parameter name="helpFileURI"/>
        <body>
        <![CDATA[
          // Try to find previously opened help.
          var topWindow = this.locateHelpWindow(helpFileURI);

          if (topWindow) {
          // Open topic in existing window.
            topWindow.focus();
            topWindow.displayTopic(topic);
          }
          else {
          // Open topic in new window.
            const params = Components.classes["@mozilla.org/embedcomp/dialogparam;1"]
                                     .createInstance(Components.interfaces.nsIDialogParamBlock);
            params.SetNumberStrings(2);
            params.SetString(0, helpFileURI);
            params.SetString(1, topic);
            const ww = Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
                                 .getService(Components.interfaces.nsIWindowWatcher);
            ww.openWindow(null, "chrome://help/content/help.xul", "_blank", "chrome,all,alwaysRaised,dialog=no", params);
          }
        ]]>
        </body>
      </method>
    </implementation>
    <handlers>
      <handler event="dialoghelp">
        // currentPane is set in _selectPane for prefwindows which aren't childs.
        // So if there's no currentPane, just use the first pane.
        var pane = this.currentPane ? this.currentPane : this.preferencePanes[0];
        this.openHelp(pane.helpTopic, pane.getAttribute("helpURI"));
      </handler>
      <handler event="dialogaccept">
      <![CDATA[
        if (!this._fireEvent("beforeaccept", this)) 
          return;
        
        if (this.type == "child" && window.opener) {
          var psvc = Components.classes["@mozilla.org/preferences-service;1"]
                               .getService(Components.interfaces.nsIPrefBranch);
          var instantApply = psvc.getBoolPref("browser.preferences.instantApply");
          if (instantApply) {
            var panes = this.preferencePanes;
            for (var i = 0; i < panes.length; ++i)
              panes[i].writePreferences(true);
          }
          else {
            // Clone all the preferences elements from the child document and
            // insert them into the pane collection of the parent. 
            var pdoc = window.opener.document;
            if (pdoc.documentElement.localName == "prefwindow") {
              var currentPane = pdoc.documentElement.currentPane;
              var id = window.location.href + "#childprefs";
              var childPrefs = pdoc.getElementById(id);
              if (!childPrefs) {
                var childPrefs = pdoc.createElement("preferences");
                currentPane.appendChild(childPrefs);
                childPrefs.id = id;
              }
              var panes = this.preferencePanes;
              for (var i = 0; i < panes.length; ++i) {
                var preferences = panes[i].preferences;
                for (var j = 0; j < preferences.length; ++j) {
                  var prefID = window.location.href + "#" + preferences[j].id;
                  var preference = pdoc.getElementById(prefID);
                  if (!preference) {
                    var preference = pdoc.createElement("preference");
                    childPrefs.appendChild(preference);
                    preference.id       = prefID;
                    preference.name     = preferences[j].name;
                    preference.type     = preferences[j].type;
                    preference.inverted = preferences[j].inverted;
                    preference.readonly = preferences[j].readonly;
                    preference.disabled = preferences[j].disabled;
                  }
                  preference.value    = preferences[j].value;
                }
              }
            }
          }
        }
        else {
          var panes = this.preferencePanes;
          for (var i = 0; i < panes.length; ++i)
            panes[i].writePreferences(false);

          var psvc = Components.classes["@mozilla.org/preferences-service;1"]
                               .getService(Components.interfaces.nsIPrefService);
          psvc.savePrefFile(null);
        }
      ]]>
      </handler>
      <handler event="command">
        if (event.originalTarget.hasAttribute("pane")) {
          var pane = document.getElementById(event.originalTarget.getAttribute("pane"));
          event.originalTarget.parentNode.parentNode.parentNode.showPane(pane);
        }
      </handler>
    </handlers>
  </binding>
  
  <binding id="prefpane">
    <resources>
      <stylesheet src="chrome://apps/skin/pref/preferences.css"/>
    </resources>
    <content>
      <xul:vbox class="content-box" xbl:inherits="flex">
        <children/>
      </xul:vbox>
    </content>
    <implementation>

      <method name="writePreferences">
        <parameter name="aFlushToDisk"/>
        <body>
        <![CDATA[
          // Write all values to preferences.
          var preferences = this.preferences;
          for (var i = 0; i < preferences.length; ++i) {
            var preference = preferences[i];
            preference.batching = true;
            preference.valueFromPreferences = preference.value;
            preference.batching = false;
          }
          if (aFlushToDisk) {
            var psvc = Components.classes["@mozilla.org/preferences-service;1"]
                                 .getService(Components.interfaces.nsIPrefService);
            psvc.savePrefFile(null);
          }
        ]]>
        </body>
      </method>
      
      <property name="src" 
                onget="return this.getAttribute('src');"
                onset="this.setAttribute('src', val); return val;"/>
      <property name="selected" 
                onget="return this.getAttribute('selected') == 'true';"
                onset="this.setAttribute('selected', val); return val;"/>
      <property name="image" 
                onget="return this.getAttribute('image');"
                onset="this.setAttribute('image', val); return val;"/>
      <property name="label" 
                onget="return this.getAttribute('label');"
                onset="this.setAttribute('label', val); return val;"/>
      
      <property name="preferenceElements"
                onget="return this.getElementsByAttribute('preference', '*');"/>
      <property name="preferences"
                onget="return this.getElementsByTagName('preference');"/>

      <property name="helpTopic">
        <getter>
        <![CDATA[
          // if there are tabs, and the selected tab provides a helpTopic, return that
          var box = this.getElementsByTagName("tabbox");
          if (box[0]) {
            var tab = box[0].selectedTab;
            if (tab && tab.hasAttribute("helpTopic"))
              return tab.getAttribute("helpTopic");
          }

          // otherwise, return the helpTopic of the current panel
          return this.getAttribute("helpTopic");
        ]]>
        </getter>
      </property>

      <field name="_loaded">false</field>
      <property name="loaded" 
                onget="return !this.src ? true : this._loaded;"
                onset="this._loaded = val; return val;"/>
      
      <method name="preferenceForElement">
        <parameter name="aElement"/>
        <body>
          return document.getElementById(aElement.getAttribute("preference"));
        </body>
      </method>
      
      <method name="getPreferenceElement">
        <parameter name="aStartElement"/>
        <body>
        <![CDATA[
          var temp = aStartElement;
          while (temp && temp.nodeType == Node.ELEMENT_NODE && 
                 !temp.hasAttribute("preference"))
            temp = temp.parentNode;
          return temp.nodeType == Node.ELEMENT_NODE ? temp : aStartElement;
        ]]>
        </body>
      </method>
      
      <method name="userChangedValue">
        <parameter name="aElement"/>
        <body>
        <![CDATA[
          var element = this.getPreferenceElement(aElement);
          if (element.hasAttribute("preference")) {
            var preference = document.getElementById(element.getAttribute("preference"));
            var prefVal = preference.getElementValue(element);
            preference.value = prefVal;
          }
        ]]>
        </body>
      </method>
      
      <property name="contentHeight">
        <getter>
          var targetHeight = parseInt(window.getComputedStyle(this._content, "").height);
          targetHeight += parseInt(window.getComputedStyle(this._content, "").marginTop);
          targetHeight += parseInt(window.getComputedStyle(this._content, "").marginBottom);
          return targetHeight;
        </getter>
      </property>
      <field name="_content">
        document.getAnonymousElementByAttribute(this, "class", "content-box");
      </field>
    </implementation>
    <handlers>
      <handler event="command">
        // This "command" event handler tracks changes made to preferences by 
        // the user in this window. 
        this.userChangedValue(event.target);
      </handler>
      <handler event="select">
        // This "select" event handler tracks changes made to colorpicker 
        // preferences by the user in this window.
        if (event.target.localName == "colorpicker") 
          this.userChangedValue(event.target);
      </handler>
      <handler event="change">
        // This "change" event handler tracks changes made to preferences by 
        // the user in this window. 
        this.userChangedValue(event.target);
      </handler>
      <handler event="input">
        // This "input" event handler tracks changes made to preferences by 
        // the user in this window.
        this.userChangedValue(event.target);
      </handler>
      <handler event="paneload">
      <![CDATA[
        // Initialize all values from preferences.
        var elements = this.preferenceElements;
        for (var i = 0; i < elements.length; ++i) {
          try {
            var preference = this.preferenceForElement(elements[i]);
            preference.setElementValue(elements[i]);
          }
          catch (e) {
            dump("*** No preference found for " + elements[i].getAttribute("preference") + "\n");
          }
        }
      ]]>      
      </handler>
    </handlers>
  </binding>
          
  <binding id="panebutton" extends="chrome://global/content/bindings/radio.xml#radio">
    <resources>
      <stylesheet src="chrome://apps/skin/pref/preferences.css"/>
    </resources>
    <content>
      <xul:image class="paneButtonIcon"  xbl:inherits="src"/>
      <xul:label class="paneButtonLabel" xbl:inherits="value=label"/>
    </content>
  </binding>

</bindings>


